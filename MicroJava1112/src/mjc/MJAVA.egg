-- PROJET3 STL 11-12 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;
inh tds : TDS for ENTITES, DEFCLASSE, DEFINTERFACE, CORPS, DEF, DEFS, BLOC, MCORPS, INST, INSTS;

-- Permet de compter le nombre d'attributs d'une classe/interface, afin de savoir la taille
-- qu'elle va occuper en mémoire
inh hnbAttr : INTEGER for CORPS, DEF, DEFS;
syn nbAttr : INTEGER for CORPS, DEF, DEFS;

-- les terminaux 

space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar interface is  "interface";
sugar etend is  "extends";
sugar implemente is  "implements";
sugar retour is  "return";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
PROGRAMME -> #init ENTITES #gen;
global
   machine : AbstractMachine;
   t : TDS;
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   t := new TDS();
   ENTITES^tds := t;
end
}

#gen {
local
do
    call machine.writeCode(PROGRAMME^source.getFileName(), "");
    write "tds " + t;
end
}

ENTITES -> ;
ENTITES -> #tds DEFCLASSE ENTITES  ;

#tds {
do
    DEFCLASSE^tds := ENTITES^tds;
    ENTITES1^tds := ENTITES^tds;
end
}

ENTITES -> #tds DEFINTERFACE ENTITES  ;

#tds {
do
    DEFINTERFACE^tds := ENTITES^tds;
    ENTITES1^tds := ENTITES^tds;
end
}

-- definition d'une classe
DEFCLASSE -> classe ident SUPER #attr CORPS #tds;

#attr {
do
    CORPS^tds := DEFCLASSE^tds;
    CORPS^hnbAttr := 0;
end
}

#tds {
local
    info : INFO;
    t : DTYPE;
do
    info := DEFCLASSE^tds.chercherGlobalement(ident^txt);
    if info /= nil then
        error(err_ident_already_known, "La classe", ident^txt);
    else
        t := new DTYPE(ident^txt, CORPS^nbAttr);
        call DEFCLASSE^tds.inserer(ident^txt, new INFOCLASS(t, false));
    end
end
}

--DEFCLASSE -> classe ident etend ident CORPS ;
--DEFCLASSE -> classe ident implemente ident CORPS ;
DEFINTERFACE -> interface ident SUPER #attr CORPS #tds;

#attr {
do
    CORPS^tds := DEFINTERFACE^tds;
    CORPS^hnbAttr := 0;
end
}

#tds {
local
    info : INFO;
    t : DTYPE;
do
    info := DEFINTERFACE^tds.chercherGlobalement(ident^txt);
    if info /= nil then
        error(err_ident_already_known, "L'interface", ident^txt);
    else
        t := new DTYPE(ident^txt, CORPS^nbAttr);
        call DEFINTERFACE^tds.inserer(ident^txt, new INFOCLASS(t, false));
    end
end
}
--DEFINTERFACE -> interface ident etend ident CORPS;
-- 1 extends maximum suivi d'un implements maximum
SUPER -> ETEND IMPL ;
ETEND -> ;
ETEND -> etend ident ;
IMPL -> ;
IMPL -> implemente ident ;
CORPS -> aco #tds DEFS #attr acf ;

global t : TDS;
#tds {
do
    t := new TDS(CORPS^tds);
    DEFS^tds  := t;
end
}

#attr {
do
    CORPS^nbAttr := DEFS^nbAttr;
--    write "\n" + t;
end
}
-- les attributs
DEFS -> #attr  ;
#attr {
do
    DEFS^nbAttr := DEFS^hnbAttr;
end
}

DEFS ->  #tds DEF #attr DEFS #attr2 ;
#tds {
do
    DEF^tds := DEFS^tds;
    DEFS1^tds := DEFS^tds;
    DEF^hnbAttr := DEFS^hnbAttr;
end
}
#attr {
do
    DEFS1^hnbAttr := DEF^nbAttr;
end
}
#attr2 {
do
    DEFS^nbAttr := DEF^nbAttr + DEFS1^nbAttr;
end
}

-- attribut
DEF ->  TYPE ident pv #attr ;
#attr {
local
info : INFO;
do
    info := DEF^tds.chercherLocalement(ident^txt);
    if info /= nil then
        error(err_ident_already_known, "L'attribut", ident^txt);
    else
    -- TODO: insérer l'attribut avec le bon type.
        call DEF^tds.inserer(ident^txt, new INFO(new DTYPE(ident^txt, 1)));
        DEF^nbAttr := 1;
    end
end
}

-- methode (fonction) 
DEF ->  TYPE ident paro PARFS parf #tds MCORPS #attr ;
#tds {
do
    MCORPS^tds := new TDS(DEF^tds);
end
}

#attr {
do
    DEF^nbAttr := 0;
end
}
-- methode (procedure)
DEF ->  void ident paro PARFS parf #tds MCORPS #attr ;
#tds {
do
    MCORPS^tds := DEF^tds;
end
}

#attr {
do
    DEF^nbAttr := 0;
end
}
-- dans classe ou dans interface
MCORPS -> pv ;
MCORPS -> #tds BLOC ;
#tds {
do
    BLOC^tds := MCORPS^tds;
end
}
-- constructeur
DEF -> ident paro PARFS parf #tds BLOC #attr ;
#tds {
do
    BLOC^tds := new TDS(DEF^tds);
end
}
#attr {
do
    DEF^nbAttr := 0;
end
} 

-- les types
TYPE-> int  ;
TYPE-> bool ;
TYPE-> ident ;
-- parametres de methodes
PARFS ->  ;
PARFS ->  PARF PARFSX ;
PARFSX ->  ;
PARFSX -> virg  PARF  PARFSX ;
PARF ->  TYPE ident  ;
-- corps de methode et bloc d'instructions
BLOC ->  aco #tds INSTS acf  ;
#tds {
do
    INSTS^tds := BLOC^tds;
end
}
-- instructions
INSTS ->   ;
INSTS ->  INST INSTS  ;
-- declaration de variable locale avec ou sans init
INST->  TYPE ident AFFX pv ;
-- instruction expression
INST ->  E pv ;
-- bloc d'instructions
INST ->  BLOC  ;
-- conditionnelle
INST ->  si paro E parf #tds BLOC SIX ;
#tds {
do 
    BLOC^tds := new TDS();
end
}
SIX ->   sinon #tds BLOC ;
#tds {
do
    BLOC^tds := new TDS();
end}
SIX ->;
-- return
INST ->  retour E pv ;
-- les expressions
E ->  ER AFFX ;
-- affectation
AFFX ->  affect ER  ;
AFFX -> ;
-- relation
ER ->   ES ERX ;
ES ->  T ESX ;
ERX ->  OPREL ES ;
ERX -> ;
OPREL -> inf ;
OPREL -> infeg ;
OPREL -> sup ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;
-- addition, ...
ESX ->   OPADD T ESX ;
ESX ->;
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;
T ->  F TX ;
-- multiplication, ...
TX ->   OPMUL F TX ;
TX -> ;
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;
-- expressions de base
F -> entier  ;
F -> vrai  ;
F -> faux  ;
-- unaire
F ->  OPUN F ;
OPUN -> plus;
OPUN -> moins;
OPUN -> non;
-- null
F -> null  ;
F ->  paro E parf ;
-- new
F -> nouveau  TYPE paro ARGS parf  ;
F ->  ident Q ;
-- Q = qualificateur de variable
Q ->  ;
-- acces attribut
Q ->  pt ident  Q ;
-- arguments d'appel de methode
Q ->  paro ARGS parf Q ;
ARGS ->  E ARGSX  ;
ARGS -> ;
ARGSX ->   virg E ARGSX  ;
ARGSX -> ;

end
