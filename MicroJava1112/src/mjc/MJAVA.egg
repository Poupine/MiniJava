-- PROJET3 STL 11-12 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

-- La table des declarations. Accessible par (presque) tout le monde...
-- Peut-on faire une variable globale au compilo ?
inh tdd : TDD for ENTITES, DEFCLASSE, DEFINTERFACE, SUPER, ETEND, IMPL, CORPS, DEFS, DEF, TYPE, 
            PARFS, PARF, PARFSX, MCORPS,  BLOC, INSTS, INST, E, AFFX, ER, ES, ERX, T, ESX, F, TX,
            ARGS, ARGSX, Q, SIX;

-- la classe courante
inh clazz : Clazz for SUPER, CORPS, ETEND, IMPL, DEFS, DEF, PARFS, PARFSX, PARF, MCORPS, BLOC, INSTS, INST,
            E, AFFX, ER, ERX, ES, ESX, T, TX, F, ARGS, ARGSX, Q, SIX;

-- Le TYPAGE
syn type : DTYPE for TYPE, PARF, AFFX, E, ER, ERX, ES, ESX, T, TX, F, Q;
inh ltype : DTYPE for ERX, ESX, TX;
inh lname : STRING for Q;
inh lclazz : Clazz for Q;

-- La signature des methodes
syn signature : Signature for PARFS, PARFSX, ARGS, ARGSX;

-- Le domaine des operateurs
syn domain : Domain for OPREL, OPADD, OPMUL, OPUN;
-- On doit pouvoir tester l'égalité entre entiers et également entre booléen
inh opType : DTYPE for OPREL;

inh tds : TDS for PARFS, PARFSX, PARF, MCORPS, BLOC, INST, INSTS, SIX, E, AFFX, ER, ERX, ES, ESX, T, TX, F, Q, ARGS, ARGSX;

-- Le retour des methodes
inh tailleArgs : Integer for MCORPS, BLOC, INSTS, INST, SIX;
inh returns : DTYPE for MCORPS, BLOC, INSTS, INST, SIX;
inh hreturned : BOOLEAN for MCORPS, BLOC, INSTS, INST, SIX;
syn sreturned : BOOLEAN for MCORPS, BLOC, INSTS, INST, SIX;

-- La generation de code
inh generator : IGenerator for PROGRAMME, ENTITES, DEFCLASSE, DEFINTERFACE, CORPS, DEFS, DEF,
                                MCORPS, BLOC, INSTS, INST, SIX, E, AFFX, ER, ERX, ES, ESX, T,
                                TX, F, Q, ARGSX, ARGS, OPREL, OPADD, OPMUL, OPUN;
syn code : String for ARGS, ARGSX, Q, F, TX, T, ESX, ES, ERX, ER, AFFX, E, SIX, INSTS, INST,
                        BLOC, MCORPS, DEFINTERFACE, DEFCLASSE, ENTITES, OPREL, OPADD, OPMUL, OPUN, CORPS,
                        DEFS, DEF;
                        
-- Les adresses courantes dans chaque bloc
syn addr : Integer for DEF, DEFS, INSTS, INST;
inh laddr : Integer for DEF, DEFS, INSTS, INST, BLOC, SIX;

-- Le déplacement des arguments passés à la méthode
inh ldep : Integer for PARFS, PARFSX, PARF;
syn dep : Integer for PARFS, PARF, PARFSX;
-- Détermine si l'évaluation d'une expression doit engendrer une lecture ou une écriture mémoire
inh genWrite : BOOLEAN for AFFX, ER, ES, T, F, ERX, ESX, TX;

-- On doit savoir le nom de l'ident à affecter dans le cas F -> nouveau ...
inh name : String for F, T, ES, ER, AFFX;

-- les terminaux 

space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar interface is  "interface";
sugar etend is  "extends";
sugar implemente is  "implements";
sugar retour is  "return";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
--The AXIOM
PROGRAMME -> #init ENTITES #gen;
global
   machine : AbstractMachine;
   t : TDD;
   generator : IGenerator;
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   t := new TDD();
   generator := new TamGenerator();
   ENTITES^tdd := t;
   ENTITES^generator := generator;
end
}

#gen {
local
do
    call machine.writeCode(PROGRAMME^source.getFileName(), generator.generateHeader() + ENTITES^code);
    write "table des classes \n" + t;
end
}

-- Entites : Declaration of classes and interfaces
ENTITES -> #gen ;

-- Generation du code
#gen{
do
    ENTITES^code := "";
end
}

ENTITES -> DEFCLASSE ENTITES #gen ;

-- Generation du code
#gen{
do
    ENTITES^code := DEFCLASSE^code + ENTITES1^code;
end
}

ENTITES -> DEFINTERFACE ENTITES #gen ;

-- Generation du code
#gen{
do
    ENTITES^code := DEFINTERFACE^code + ENTITES1^code;
end
}

-- definition d'une classe
DEFCLASSE -> classe ident #down #tdd SUPER CORPS #check #gen ;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;
    generate : BOOLEAN;

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(ident^txt, false);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tdd {
do
    -- Vérifie que l'identifiant de la classe n'existe pas déjà.
    info := DEFCLASSE^tdd.containsKey(ident^txt);
    if info then
        -- ERROR
        generate := false;
        error(err_class_exists, ident^txt);
    else
        -- Ajout à la table des déclarations.
        generate := true;
        call DEFCLASSE^tdd.put(ident^txt, clazz);
    end
end
}

-- Verifie qu'on implemente bien l'interface
-- Ajoute (si necessaire) le constructeur par defaut.
#check{
local
    impl : Clazz;
    method : MethodList;
    signature : Signature;
do
    if clazz.checkImplements() then
        generate := generate & true;
    else
        impl := clazz.getImplemented();
        error(err_implement, clazz.getName(), impl.getName());
        generate := generate & false;
    end
end
}

-- Generation du code
#gen{
do
    if generate then
        DEFCLASSE^code := DEFCLASSE^generator.generateVtable(clazz) + CORPS^code;
    end
end
}

--DEFCLASSE -> classe ident etend ident CORPS ;
--DEFCLASSE -> classe ident implemente ident CORPS ;
--DEFCLASSE -> classe ident etend ident implemente ident CORPS ;
DEFINTERFACE -> interface ident #down #tdd SUPER CORPS #gen ;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;
    generate : BOOLEAN;

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(ident^txt, true);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tdd {
do
    -- Vérifie que l'identifiant de l'interface n'existe pas déjà.
    info := DEFINTERFACE^tdd.containsKey(ident^txt);
    if info then
        -- Ne fait rien puisque la declaration de la classe est invalide
        -- ERROR
        generate := false;
        error(err_class_exists, ident^txt);
    else
        -- Ajout à la table de déclarations.
        call DEFINTERFACE^tdd.put(ident^txt, clazz);
        generate := true;
    end
end
}

-- Generation du code
#gen{
do
    if generate then
        DEFINTERFACE^code := CORPS^code;
    end
end
}

--DEFINTERFACE -> interface ident etend ident CORPS;
-- 1 extends maximum suivi d'un implements maximum
SUPER -> ETEND IMPL #checkcompatible ;

-- Teste la compatibilite de ETEND et IMPL
#checkcompatible{
local
    extend : Clazz;
    impl : Clazz;
do
    if SUPER^clazz.testExtendImplementCompatible() then
        -- Le cas cool, rien a faire, pas de problemes
    else
        -- ERROR
        extend := SUPER^clazz.getExtended();
        impl := SUPER^clazz.getImplemented();
        error(err_extend_and_implement_incompatible, extend.getName(), impl.getName());
    end
end
}

ETEND -> ;

ETEND -> etend ident #up ;

-- Verifie la validite de l'extend et l'enregistre dans la classe
#up{
local
    ext : Clazz;
do
    ext := ETEND^tdd.get(ident^txt);
    -- Vérifie qu'on peut hériter de l'identifiant spécifié.
    if (ext /= nil & ETEND^clazz.canExtend(ext)) then
        -- Vérifie qu'on n'hérite que d'une seule classe.
        if ETEND^clazz.getExtended() = nil then
            call ETEND^clazz.setExtended(ext);
        else
            -- ERROR
            error(err_max_ext_one, ETEND^clazz.getName());
        end
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if ETEND^clazz.isInterfaze() then
            -- ERROR
            error(err_interface_cannot_extend_class, ETEND^clazz.getName(), ident^txt);
        else
            if ext = nil then
                -- ERROR
                error(err_unknown_class, ident^txt);
            else
                -- ERROR
                error(err_class_cannot_extend_interface, ETEND^clazz, ident^txt);
            end
        end
    end
end
}

IMPL -> ;

IMPL -> implemente ident #up ;

-- Verifie la validite de l'implements et l'enregistre dans la classe
#up{
local
    impl : Clazz;
do
    impl := IMPL^tdd.get(ident^txt);
    -- Vérifie qu'on peut implémenter l'identifiant spécifié.
    if (impl /= nil & IMPL^clazz.canImplement(impl)) then
        if IMPL^clazz.getImplemented() = nil then
            call IMPL^clazz.setImplemented(impl);
        else
            -- ERROR
            error(err_max_impl_one, IMPL^clazz.getName());
        end
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if IMPL^clazz.isInterfaze() then
            -- ERROR
            error(err_interface_cannot_implement_class, IMPL^clazz.getName(), ident^txt);
        else
            -- ERROR
            error(err_unknown_interface, ident^txt);
       end
    end
end
}

CORPS -> aco #addr DEFS #gen acf ;
#addr {
do
    DEFS^laddr := 0;
end
}

#gen {
do
    CORPS^code := DEFS^code;
end
}

-- les attributs
DEFS -> #gen;
#gen {
do
    DEFS^code := "";
    DEFS^addr := DEFS^laddr;
end
}

DEFS -> DEF #addr DEFS #gen;

#addr {
do
    DEFS1^laddr := DEF^addr;
end
}

#gen {
do
    DEFS^addr := DEFS1^addr;
    DEFS^code := DEF^code + DEFS1^code;
end
}

-- attribut
DEF ->  TYPE ident pv #attr ;

-- Ajoute un attribut.
#attr {
do
    if DEF^clazz.hasAttribute(ident^txt) then
        -- ERROR
        error(err_attribute_already_named, ident^txt);
    elseif DEF^clazz.isInterfaze() then
        -- ERROR: Une interface ne peut pas déclarer d'attribut.
        error(err_attribute_interface, DEF^clazz.getName());
    end
    call DEF^clazz.addAttribute(ident^txt, TYPE^type);
    DEF^code := ""; -- Génération (Rien à faire, puisque que l'objet n'est pas encore instancié.
    DEF^addr := DEF^laddr + TYPE^type.getTaille();
end
}

-- methode (fonction) 
DEF ->  TYPE ident #checkname paro #down PARFS parf #check #downbody MCORPS #gen ;

global
    tds : TDS;
    generate : BOOLEAN;
    etiquette : String;
    
-- Verifie la bonne denomination de la methode
#checkname {
do
    if DEF^clazz.validMethodName(ident^txt) then
        if DEF^clazz.validMethodType(ident^txt, TYPE^type) then
            -- OK
        else
            -- ERROR
            error(err_wrong_signature, ident^txt);
        end
    else
        -- ERROR
        error(err_meth_name, DEF^clazz.getName());
    end
end
}

-- Passe la tds a PARFS
#down{
do
    tds := new TDS();
    PARFS^tds := tds;
    PARFS^ldep := 0;
end
}

-- Verifie la validite de la signature
#check{
do
    if DEF^clazz.addMethod(ident^txt, TYPE^type, PARFS^signature) then
        -- OK
        generate := true;
    else
        -- ERROR
        generate := false;
        error(err_wrong_signature, PARFS^signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
    MCORPS^returns := TYPE^type;
    MCORPS^hreturned := false;
    DEF^addr := DEF^laddr;
    etiquette := DEF^generator.generateEtiquette();
    call DEF^clazz.addEtiquette(ident^txt, etiquette);
    MCORPS^tailleArgs := PARFS^dep + 2;
end
}

-- Generation du code
#gen{
do
    if DEF^clazz.isInterfaze()then
    
    else
        if MCORPS^sreturned = false then
            error(err_method_must_return, ident^txt);
        end
    end
    if generate then
    -- TODO: Générer une erreur si on trouve une fonction main (main ne peut pas retourner de valeur)
        DEF^code := DEF^generator.generateMethod(DEF^clazz, etiquette, ident^txt) + MCORPS^code;
    end
end
}

-- methode (procedure)
DEF ->  void ident #checkname paro #down PARFS parf #check #downbody MCORPS #gen ;

global
    tds : TDS;
    generate : BOOLEAN;
    
-- Verifie la bonne denomination de la methode
#checkname {
do
    if DEF^clazz.validMethodName(ident^txt) then
        if DEF^clazz.validMethodType(ident^txt, new DTYPE("Null", 1)) then
            -- OK
        else
            -- ERROR
            error(err_wrong_signature, ident^txt);
        end
    else
        -- ERROR
        error(err_meth_name, DEF^clazz.getName());
    end
end
}

-- Passe la tds a PARFS
#down{
do
    tds := new TDS();
    PARFS^tds := tds;
    PARFS^ldep := 0;
end
}

-- Verifie la validite de la signature
#check{
do
    if DEF^clazz.addMethod(ident^txt, new DTYPE("Null", 1), PARFS^signature) then
        -- OK
        generate := true;
    else
        -- ERROR
        generate := false;
        error(err_wrong_signature, PARFS^signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
    MCORPS^returns := nil;
    MCORPS^hreturned := false;
    DEF^addr := DEF^laddr;
    MCORPS^tailleArgs := 0;
end
}

-- Generation du code
#gen{
local
etiquette : String;
do
    if ~ident^txt.equals("main") then
        if MCORPS^sreturned = true then
            error(err_proc_no_return, ident^txt);
        end
        if generate then
            etiquette := DEF^generator.generateEtiquette();
            call DEF^clazz.addEtiquette(ident^txt, etiquette);
            DEF^code := DEF^generator.generateMethod(DEF^clazz, etiquette, ident^txt) + MCORPS^code + DEF^generator.generateReturn(0, 0);
        end
    else
        if DEF^generator.canCreateMain() then
            DEF^code := DEF^generator.generateMain() + MCORPS^code + DEF^generator.generateReturn(0, 0);
        else 
            error(err_multiple_main);
            DEF^code := "";
        end
    end
end
}

-- dans classe ou dans interface
MCORPS -> pv #check #gen ;

-- Verifie qu'on est dans une interface !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        -- Rien a faire
    else
        -- ERROR
        error(err_meth_not_specified, MCORPS^clazz.getName());
    end
end
}

-- Generation du code
#gen{
do
    MCORPS^code := "";
    MCORPS^sreturned := false;
end
}

MCORPS -> #check #down BLOC #gen ;

-- Verifie qu'on est dans une classe concrete !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        -- ERROR
        error(err_meth_body_in_interface, MCORPS^clazz.getName());
    else
        -- Rien à faire
    end
end
}

-- Initialise la variable returned
#down{
do
    BLOC^hreturned := false;
    BLOC^laddr := 3;
    BLOC^tailleArgs := MCORPS^tailleArgs;
end
}

-- Generation du code
#gen{
do
    MCORPS^sreturned := BLOC^sreturned;
    MCORPS^code := BLOC^code;
end
}

-- constructeur
DEF -> ident #checkname paro #down PARFS #check parf #downbody BLOC #gen ;

global
    tds : TDS;
    generate : BOOLEAN;
    
-- Verifie la bonne denomination du constructeur
#checkname {
do
    if DEF^clazz.isInterfaze() then
        error(err_interface_constructor, DEF^clazz.getName());
    else
        if ident^txt.equals(DEF^clazz.getName()) then
            -- OK
        else
            -- ERROR
            error(err_constructor_name, DEF^clazz.getName());
        end
    end
end
}

-- Passe la tds a PARFS
#down{
do
    tds := new TDS();
    PARFS^tds := tds;
    PARFS^ldep := 0;
end
}

-- Verifie la validite de la signature
#check{
local
    
do
    if DEF^clazz.addConstructor(PARFS^signature) then
        -- OK
        generate := true;
    else
        -- ERROR
        generate := false;
        error(err_constructor, ident^txt);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    BLOC^tds := tds;
    BLOC^hreturned := false;
    BLOC^returns := nil;
    BLOC^laddr := 3;
    BLOC^tailleArgs := PARFS^dep;
end
}

-- Generation du code
#gen{
local
    etiquette : String;
do
    DEF^addr := DEF^laddr;
    if generate then
        etiquette := DEF^generator.generateEtiquette();
        call DEF^clazz.addEtiquette(ident^txt, etiquette);
        DEF^code := DEF^generator.generateConstructor(DEF^clazz, etiquette) + BLOC^code;
        -- Manque le return 
    end
end
}

-- les types
TYPE-> int #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Integer", 1);
end
}

TYPE-> bool #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Boolean", 1);
end
}

TYPE-> ident #type ;

-- Set le type de TYPE
#type{
local
    clazz : Clazz;
do
    clazz := TYPE^tdd.get(ident^txt);
    if clazz /= nil then
        TYPE^type := new Pointer(clazz);
    else
        TYPE^type := nil;
        -- ERROR
        error(err_unknown_class, ident^txt);
    end
end
}

-- parametres de methodes
PARFS -> #up ;

-- Remonte la signature
#up{
do
    PARFS^signature := new Signature();
    PARFS^dep := PARFS^ldep;
end
}

PARFS -> PARF #dep PARFSX #up ;
-- Remonte la signature
#dep {
do
    PARFSX^ldep := PARF^dep;
end
}

#up{
local
    signature : Signature;
do
    signature := PARFSX^signature;
    call signature.add(0, PARF^type);
    PARFS^signature := signature;
    PARFS^dep := PARFSX^dep;
end
}

PARFSX -> #up ;

-- Remonte la signature
#up{
do
    PARFSX^signature := new Signature();
    PARFSX^dep := PARFSX^ldep;
end
}

PARFSX -> virg  PARF #dep PARFSX #up ;
#dep {
do
    PARFSX1^ldep := PARF^dep;
end
}
-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := PARFSX1^signature;
    call signature.add(0, PARF^type);
    PARFSX^signature := signature;
    PARFSX^dep := PARFSX1^dep;
end
}

PARF ->  TYPE ident #sign ;

-- Ajoute l'element dans la tds et remonte le type
#sign{
local
    dep : Integer;
do
    -- TODO: Vérifier que l'argument n'existe pas déjà dans la tds.
    PARF^type := TYPE^type;
    if PARF^tds.chercherGlobalement(ident^txt) /= nil then
        -- ERROR
        error(err_variable_already_defined, ident^txt);
    else
        if PARF^clazz.hasAttribute(ident^txt) then
            -- ERROR
            error(err_hidding, ident^txt);
        else
            dep := PARF^ldep + TYPE^type.getTaille();
            call PARF^tds.inserer(ident^txt, new INFO(TYPE^type, 0 - dep + 1));
            PARF^dep := dep;
        end
    end
end
}

-- corps de methode et bloc d'instructions
BLOC -> aco #addr INSTS acf #up #gen ;
#addr {
do
    INSTS^laddr := BLOC^laddr;
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    BLOC^sreturned := INSTS^sreturned;
end
}

-- Generation du code
#gen{
do
    BLOC^code := INSTS^code;
end
}

-- instructions
INSTS -> #up #gen ;

-- Remonte les attributs
--  * sreturned
#up{
do
    INSTS^sreturned := INSTS^hreturned;
end
}

-- Generation du code
#gen{
do
    INSTS^code := "";
    INSTS^addr := INSTS^laddr;
end
}

INSTS -> #testReturn INST #transmit INSTS #up #gen ;

global
    generate : BOOLEAN;

-- Passe le statut de retour a INSTS
#testReturn{
do
    if INSTS^hreturned then
        generate := false;
        error(err_unreachable_code);
    else
        generate := true;
    end
end
}

-- Remonte les attributs
--  * sreturned
#transmit{
do
    INSTS1^laddr := INST^addr;
    INSTS1^hreturned := INST^sreturned;
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    INSTS^sreturned := INSTS1^sreturned;
end
}

-- Generation du code
#gen{
do
    if generate then
        INSTS^addr := INST^addr;
        INSTS^code := INST^code + INSTS1^code;
    end
end
}

-- declaration de variable locale avec ou sans init
INST-> TYPE ident #check AFFX pv #checktype #up #gen ;

global
    generate : BOOLEAN;

#check{
local
    info : INFO;
do
    info := INST^tds.chercherGlobalement(ident^txt);
    if info /= nil then
        -- ERROR
        generate := false;
        error(err_variable_already_named, ident^txt);
    else
        if INST^clazz.hasAttribute(ident^txt) then
            -- ERROR
            generate := false;
            error(err_hidding, ident^txt);
        else
            generate := true;
            call INST^tds.inserer(ident^txt, new INFO(TYPE^type, INST^laddr + TYPE^type.getTaille()));
        end
    end
    -- Ici, on se trouve à droite de l'expression, donc on va générer une lecture en mémoire
    AFFX^genWrite := false;
    AFFX^name := ident^txt;
end
}

-- Teste la compatibilite des types et affecte ident dans la tds.
#checktype{
do
    if AFFX^type /= nil then
        if AFFX^type.isType(TYPE^type) then
            INST^addr := INST^laddr + TYPE^type.getTaille();
        else
            -- ERROR
            generate := false;
            error(err_type, AFFX^type.getName(), TYPE^type.getName());
        end
    else
        INST^addr := INST^laddr + TYPE^type.getTaille();
    end
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^sreturned := INST^hreturned;
end
}

-- Generation du code
#gen{
do
--    INST^addr := TYPE^type.getTaille();
    if generate then
        INST^addr := INST^laddr + TYPE^type.getTaille();
        INST^code := INST^generator.generateAffectation(ident^txt, AFFX^code, TYPE^type.getTaille());
    end
end
}

-- instruction expression
INST -> E pv #up #gen ;

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^sreturned := INST^hreturned;
end
}

-- Generation du code
#gen{
do
    INST^addr := INST^laddr;
    INST^code := E^code;
end
}

-- bloc d'instructions
INST -> #tds BLOC #up #gen ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(INST^tds);
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^addr := INST^laddr;
    INST^sreturned := BLOC^sreturned;
end
}

-- Generation du code
#gen{
do
--    INST^addr := BLOC^addr;
    INST^code := BLOC^code;
end
}

-- conditionnelle
INST -> si paro #tds ER parf BLOC SIX #up #gen ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(INST^tds);
    ER^genWrite := false;
    ER^name := "";
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^sreturned := BLOC^sreturned & SIX^sreturned;
end
}

-- Generation du code
#gen{
do
    INST^addr := INST^laddr;
    INST^code := INST^generator.generateIfThenElse(ER^code, BLOC^code, SIX^code);
end
}

SIX -> #up #gen ;

-- Remonte les attributs
--  * sreturned
#up{
do
    SIX^sreturned := false;
end
}

-- Generation du code
#gen{
do
    SIX^code := "";
end
}

SIX -> sinon #tds BLOC #up #gen ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(SIX^tds);
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    SIX^sreturned := BLOC^sreturned;
end
}

-- Generation du code
#gen{
do
    SIX^code := BLOC^code;
end
}

-- return
INST ->  retour #genWrite ER pv #up #gen ;
#genWrite {
do
    ER^genWrite := false;
    ER^name := "";
end
}

global
    generate : BOOLEAN;

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^sreturned := true;
    if ER^type.isType(INST^returns) then
        generate := true;
    else
        generate := false;
        error(err_return_type, ER^type.getName(), INST^returns.getName());
    end
end
}

-- Generation du code
#gen{
do
    if generate then
        INST^addr := INST^laddr;
        INST^code := ER^code + INST^generator.generateReturn(ER^type.getTaille(), INST^tailleArgs);
    end
end
}

-- les expressions
E -> #genWrite ER AFFX #checktype #up #gen ;

global
    generate : BOOLEAN;

#genWrite {
do
    ER^genWrite := true;
    AFFX^genWrite := false;
    ER^name := "";
    AFFX^name := "";
end
}

-- Teste la compatibilite des types
#checktype{
do
    generate := true;
    if AFFX^type /= nil then
		if AFFX^type.isType(ER^type) then
		    -- OK
		else
		    -- ERROR
		    generate := false;
		    error(err_type, AFFX^type.getName(), ER^type);
		end
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    if AFFX^type = nil then
        E^type := ER^type;
    else
        E^type := AFFX^type;
    end
end
}

-- Generation du code
#gen{
do
    if generate then
        E^code := AFFX^code + ER^code;
    end
end
}

-- affectation
AFFX ->  affect #name ER #up #gen ;
#name {
do
    ER^name := AFFX^name;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    AFFX^type := ER^type;
end
}

-- Generation du code
#gen{
do
    AFFX^code := ER^code;
end
}

AFFX -> #up #gen ;

-- Remonte les attributs :
--  * type
#up{
do
    AFFX^type := nil;
end
}

-- Generation du code
#gen{
do
    AFFX^code := "";
end
}

-- relation
ER -> #name ES #down ERX #up #gen ;
#name {
do
    ES^name := ER^name;
end
}

-- Passe le type de gauche a ERX
#down{
do
    ERX^ltype := ES^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ER^type := ERX^type;
end
}

-- Generation du code
#gen{
do
    ER^code := ES^code + ERX^code;
end
}

ES -> #name T #down ESX #up #gen ;
#name {
do
    T^name := ES^name;
end
}

-- Passe le type de gauche a ESX
#down{
do
    ESX^ltype := T^type;
end
}


-- Remonte les attributs :
--  * type
#up{
do
    ES^type := ESX^type;
end
}

-- Generation du code
#gen{
do
    ES^code := T^code + ESX^code;
end
}

ERX ->  #opreltype OPREL ES #checktype #up #gen ;
#opreltype {
do
    OPREL^opType := ERX^ltype;
    ES^name := "";
end
}

global
    generate : BOOLEAN;

-- Verifie la compatibilite de ltype et de ES^type avec OPREL^domain
#checktype{
do
    generate := true;
    if OPREL^domain.accepts(0, ERX^ltype) then
        call OPREL^domain.restrict(0,ERX^ltype);
        if OPREL^domain.accepts(1,ES^type) then
            call OPREL^domain.restrict(1,ES^type);
        else
            -- ERROR
            generate := false;
            error(err_type, ES^type.getName(), OPREL^domain.getType(1));
        end
    else
        -- ERROR
        generate := false;
        error(err_type, ERX^ltype.getName(), OPREL^domain.getType(0));
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ERX^type := OPREL^domain.getReturnType();
end
}

-- Generation du code
#gen{
do
    ERX^code := ES^code + OPREL^code;
end
}

ERX -> #up #gen ;

-- Remonte les attributs :
--  * type
#up{
do
    ERX^type := ERX^ltype;
end
}

-- Generation du code
#gen{
do
    ERX^code := "";
end
}

OPREL -> inf #up #gen ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPREL^code := OPREL^generator.generateInf();
end
}

OPREL -> infeg #up #gen ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPREL^code := OPREL^generator.generateInfEq();
end
}

OPREL -> sup #up #gen ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPREL^code := OPREL^generator.generateSup();
end
}

OPREL -> supeg #up #gen ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPREL^code := OPREL^generator.generateSupEq();
end
}

OPREL -> eg #up #gen ;

-- Remonte le domaine
#up{
do
    if OPREL^opType.compareTo(new DTYPE("Integer", 1)) | OPREL^opType.compareTo(new DTYPE("Boolean", 1)) then
        OPREL^domain := new Domain(new DTYPE("Boolean",1), OPREL^opType, OPREL^opType);
    else
        error(err_comp);
    end
end
}

-- Generation du code
#gen{
do
    OPREL^code := OPREL^generator.generateEq();
end
}

OPREL -> neg #up #gen ;

-- Remonte le domaine
#up{
do
    if OPREL^opType.compareTo(new DTYPE("Integer", 1)) | OPREL^opType.compareTo(new DTYPE("Boolean", 1)) then
        OPREL^domain := new Domain(new DTYPE("Boolean",1), OPREL^opType, OPREL^opType);
    else
        error(err_comp);
    end
end
}

-- Generation du code
#gen{
do
    OPREL^code := OPREL^generator.generateNEq();
end
}

-- addition, ...
ESX -> OPADD #name T #checktype #down ESX #up #gen ;
#name {
do
    T^name := "";
end
}

global
    generate : BOOLEAN;
    
-- Verifie la compatibilite de ltype et de ES^type avec OPADD^domain
#checktype{
do
    generate := true;
    if OPADD^domain.accepts(0, ESX^ltype) then
        call OPADD^domain.restrict(0,ESX^ltype);
        if OPADD^domain.accepts(1,T^type) then
            call OPADD^domain.restrict(1,T^type);
        else
            -- ERROR
            generate := false;
            error(err_type, T^type.getName(), OPADD^domain.getType(1));
        end
    else
        -- ERROR
        generate := false;
        error(err_type, ESX^ltype.getName(), OPADD^domain.getType(0));
    end
end
}

-- Passe le type de gauche a ESX
#down{
do
    ESX1^ltype := OPADD^domain.getReturnType();
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ESX^type := ESX1^type;
end
}

-- Generation du code
#gen{
do
    ESX^code := T^code + ESX1^code + OPADD^code;
end
}

ESX -> #up #gen ;

-- Remonte les attributs :
--  * type
#up{
do
    ESX^type := ESX^ltype;
end
}

-- Generation du code
#gen{
do
    ESX^code := "";
end
}

OPADD -> plus #up #gen ;

-- Remonte le domaine
#up{
do
    OPADD^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPADD^code := OPADD^generator.generatePlus();
end
}

OPADD -> moins #up #gen ;

-- Remonte le domaine
#up{
do
    OPADD^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPADD^code := OPADD^generator.generateMinus();
end
}

OPADD -> ou #up #gen ;

-- Remonte le domaine
#up{
do
    OPADD^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Boolean",1), new DTYPE("Boolean",1));
end
}

-- Generation du code
#gen{
do
    OPADD^code := OPADD^generator.generateOr();
end
}

T ->  #name F #down TX #up #gen ;
#name {
do
    F^name := T^name;
end
}

-- Passe le type de gauche a ESX
#down{
do
    TX^ltype := F^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    T^type := TX^type;
end
}

-- Generation du code
#gen{
do
    T^code := F^code + TX^code;
end
}

-- multiplication, ...
TX -> OPMUL #name F #checktype #down TX #up #gen ;
#name {
do
    F^name := "";
end
}

global
    generate : BOOLEAN;

-- Verifie la compatibilite de ltype et de ES^type avec OPREL^domain
#checktype{
do
    generate := true;
    if OPMUL^domain.accepts(0, TX^ltype) then
        call OPMUL^domain.restrict(0,TX^ltype);
        if OPMUL^domain.accepts(1,F^type) then
            call OPMUL^domain.restrict(1,F^type);
        else
            -- ERROR
            generate := false;
            error(err_type, F^type.getName(), OPMUL^domain.getType(1));
        end
    else
        -- ERROR
        generate := false;
            error(err_type, TX^ltype.getName(), OPMUL^domain.getType(0));
    end
end
}

-- Passe le type de gauche a ESX
#down{
do
    TX1^ltype := OPMUL^domain.getReturnType();
end
}

-- Remonte les attributs :
--  * type
#up{
do
    TX^type := TX1^type;
end
}

-- Generation du code
#gen{
do
    TX^code := F^code + TX1^code + OPMUL^code;
end
}

TX -> #up #gen ;

-- Remonte les attributs :
--  * type
#up{
do
    TX^type := TX^ltype;
end
}

-- Generation du code
#gen{
do
    TX^code := "";
end
}

OPMUL -> mult #up #gen ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPMUL^code := OPMUL^generator.generateMult();
end
}

OPMUL -> div #up #gen ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPMUL^code := OPMUL^generator.generateDiv();
end
}

OPMUL -> mod #up #gen ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPMUL^code := OPMUL^generator.generateMod();
end
}

OPMUL -> et #up #gen ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Boolean",1), new DTYPE("Boolean",1));
end
}

-- Generation du code
#gen{
do
    OPMUL^code := OPMUL^generator.generateAnd();
end
}

-- expressions de base
F -> entier #up #gen ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Integer", 1);
end
}

-- Generation du code
#gen{
do
    F^code := F^generator.generateCst(entier^txt);
end
}

F -> vrai #up #gen ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Boolean", 1);
end
}

-- Generation du code
#gen{
do
    F^code := F^generator.generateBoolean(1);
end
}

F -> faux #up #gen ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Boolean", 1);
end
}

-- Generation du code
#gen{
do
    F^code := F^generator.generateBoolean(0);
end
}

-- unaire
F ->  OPUN F #checktype #up #gen ;

-- Verifie la compatibilite de ltype et de ES^type avec OPUN^domain
#checktype{
do
    if OPUN^domain.accepts(0, F1^type) then
        call OPUN^domain.restrict(0,F1^type);
    else
        -- ERROR
        error(err_type, F1^type.getName(), OPUN^domain.getType(0));
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    F^type := OPUN^domain.getReturnType();
end
}

-- Generation du code
#gen{
do
    F^code := F^generator.generateUnaryOperation(F1^code, OPUN^code);
end
}

OPUN -> plus #up #gen ;

-- Remonte le domaine
#up{
do
    OPUN^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPUN^code := OPUN^generator.generatePlus();
end
}

OPUN -> moins #up #gen ;

-- Remonte le domaine
#up{
do
    OPUN^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- Generation du code
#gen{
do
    OPUN^code := OPUN^generator.generateMinus();
end
}

OPUN -> non #up #gen ;

-- Remonte le domaine
#up{
do
    OPUN^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Boolean",1));
end
}

-- Generation du code
#gen{
do
    OPUN^code := OPUN^generator.generateNot();
end
}

-- null
F -> null #up #gen ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Null", 1);
end
}

-- Generation du code
#gen{
do
    F^code := F^generator.generateNull();
end
}

F ->  paro E parf #up #gen ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := E^type;
end
}

-- Generation du code
#gen{
do
    F^code := E^code;
end
}

-- new
F -> nouveau TYPE paro ARGS parf #checksignature #up #gen ;

global
-- #checksignature #gen
    clazz : Clazz;
-- #checksignature #gen
    constructors : MethodList;
-- #gen
    generate : BOOLEAN;

-- Teste l'existence du constructeur
#checksignature{
do
    match TYPE^type
        with Pointer then
            clazz := TYPE^type.getClazz();
            constructors := clazz.getConstructors();
            if constructors.isEmpty() then
                if ARGS^signature.equals(new Signature()) then
                    -- OK
                    -- TODO: Et si un constructeur est defini plus tard ?
                else
                    error(err_unknown_constructor, ARGS^signature.toString());
                end
            else
            if constructors.doAccept(ARGS^signature) then
                generate := true;
            else
                -- ERROR
                error(err_unknown_constructor, ARGS^signature.toString());
            end
            end
        else
            -- ERROR
            error(err_primitive_type);
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    F^type := TYPE^type;
end
}

-- Generation du code
#gen{
local
    info : INFO;
do
    if generate then
        info := F^tds.chercherGlobalement(F^name);
        F^code := F^generator.generateInstance(clazz) + F^generator.generateWriteStack(info) + ARGS^code + F^generator.generateCallConstructor(clazz, ARGS^signature);
    else
        F^code := "";
    end
end
}

F -> ident #up ;

-- Remonte le type et le code
#up{
local
    type : DTYPE;
    info : INFO;
do
    type := F^clazz.getAttribute(ident^txt);
    --F^code := F^generator.generateGetAttribute(ident^txt, F^clazz);
    info := new INFO(type, 4);
    if type /= nil then
    F^code := F^generator.generateWriteHeap(info);
    end
    info := F^tds.chercherGlobalement(ident^txt);
    if info /= nil then
        type := info.getType();
        if F^genWrite then
            F^code := F^generator.generateWriteStack(info);
        else
            F^code := F^generator.generateReadStack(info);
        end
    end
    F^type := type;
    if type = nil then
        F^code := "";
        error(no_such_variable, ident^txt, F^clazz);
    end
end
}

F -> ident pt ident #down Q #up ;

global info : INFO;

-- Descend les bon attribut pour Q
#down{
local
    type : DTYPE;
do
    type := F^clazz.getAttribute(ident^txt);
    info := F^tds.chercherGlobalement(ident^txt);
    if info /= nil then
        type := info.getType();
    end
    if type /= nil then
        match type
            with Pointer then
                Q^lclazz := type.getClazz();
                Q^lname := ident1^txt;
            else
                Q^lclazz := nil;
                Q^lname := nil;
                error(err_primitive_types_have_no_fields);
        end
    else
        Q^lclazz := nil;
        Q^lname := nil;
        error(no_such_variable, ident^txt, F^clazz);
    end
end
}

-- Remonte le type et le code
#up{
do
    F^type := Q^type;
    F^code := F^generator.generateReadStack(info) + Q^code;
end
}

F -> ident paro ARGS parf #down Q #up ;

global
    isPrimitif : BOOLEAN;
    method : MethodList;
    etiquette : String;

-- Descend les bon attribut pour Q
#down{
local
    type : DTYPE;
do
    Q^lname := nil;
    method := F^clazz.getMethodList(ident^txt);
    if method = nil then
        Q^lclazz := nil;
        error(no_such_function, ident^txt, F^clazz.getName());
    else
        if method.doAccept(ARGS^signature) then
            -- OK
            type := method.getReturnType();
            match type
                with Pointer then
                    Q^lclazz := type.getClazz();
                    isPrimitif := false;
                else
                    isPrimitif := true;
                Q^lclazz := nil;
            end
        else
            Q^lclazz := nil;
            error(wrong_signature);
        end
    end
end
}

-- Remonte le type et le code
#up{
do
    F^type := Q^type;
    if isPrimitif then
        F^type := method.getReturnType();
    end
    etiquette := F^clazz.getEtiquette(ident^txt, ARGS^signature);
    F^code := F^generator.generateAffectation("null", "", 2) + ARGS^code + F^generator.generateMethodCall(etiquette);
end
}

-- Q = qualificateur de variable
Q -> #up ;

-- Remonte le type
#up{
local
    info : INFO;
    type : DTYPE;
do
    if Q^lclazz = nil then
        Q^type := nil;
        Q^code := "";
    else
        if Q^lname = nil then
            type := new Pointer(Q^lclazz);
            Q^code := "";
        else
            type := Q^lclazz.getAttribute(Q^lname);
            Q^code := Q^generator.generateGetAttribute(Q^lname, Q^lclazz);
            Q^type := type;
            if type = nil then
                error(no_such_field, Q^lname, Q^lclazz.getName());
            end
	    end
    end
end
}

-- acces attribut
Q -> #checkname pt ident #down Q #up ;

global
    clazz : Clazz; -- La classe de l'element precedent

-- Recupere le type de l'element precedent et verifie qu'il n'est pas primitif
#checkname{
local
    info : INFO;
    type : DTYPE;
do
    type := Q^lclazz.getAttribute(Q^lname);
    if type /= nil then
        match type
            with Pointer then
                clazz := type.getClazz();
            else
                clazz := nil;
                error(err_primitive_types_have_no_fields);
        end
    else
        clazz := nil;
        error(no_such_field, Q^lname, Q^lclazz.getName());
    end
end
}

-- Descend les bon attribut pour Q
#down{
do
    Q1^lname := ident^txt;
    Q1^lclazz := clazz;
end
}

-- Remonte le type et le code
#up{
do
    Q^type := Q1^type;
    Q^code := Q1^code;
end
}

-- arguments d'appel de methode
Q -> #checkmethname paro ARGS parf #checkmethsign #down Q #up #gen ;

global
    method : MethodList;
    isPrimitive : BOOLEAN;

-- Verifie qu'on a un nom de methode (pas le Q de la meme regle) et qu'il represente une methode existante !
#checkmethname{
do
	if Q^lclazz /= nil then
	     if Q^lname = nil then
	            method := nil;
	        error(missing_function_call_name);
	    else
	        method := Q^lclazz.getMethodList(Q^lname);
	        if method = nil then
	            error(no_such_function, Q^lname, Q^lclazz.getName());
	        end
	    end
	end
    -- Sinon on a une erreur avant ( theoriquement)
end
}

-- Verifie, s'il y a lieu, la signature de la methode
#checkmethsign{
do
    if method /= nil then
        if method.doAccept(ARGS^signature) then
            -- OK
        else
            error(wrong_signature);
        end
    end
end
}

-- Descend les bon attribut pour Q
#down{
local
    returnType : DTYPE;
do
    Q1^lname := nil;
    if method = nil then
        Q1^lclazz := nil;
    else
        returnType := method.getReturnType();
        match returnType
            with Clazz then
                Q1^lclazz := returnType;
                isPrimitive := false;
            else
                isPrimitive := true;
                Q1^lclazz := nil;
            end
    end
end
}

-- Remonte le type et le code
#up{
do
    if isPrimitive then
        -- Si primitif, inqualifiable
        Q^type := method.getReturnType();
    else
        Q^type := Q1^type;
    end
end
}

-- Remonte le type et le code
#gen{
do
    Q^code := ARGS^code;
end
}

ARGS -> #genWrite ER ARGSX #up #gen ;
#genWrite {
do
    ER^genWrite := false;
    ER^name := "";
end
}

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := ARGSX^signature;
    call signature.add(0, ER^type);
    ARGS^signature := signature;
end
}

-- Generation de code
#gen{
do
    ARGS^code := ARGSX^code + ER^code;
end
}

ARGS -> #up #gen ;

-- Remonte la signature
#up{
do
    ARGS^signature := new Signature();
end
}

-- Generation de code
#gen{
do
    ARGS^code := "";
end
}

ARGSX -> virg #genWrite E ARGSX #up #gen ;
#genWrite {
do
end    
}

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := ARGSX1^signature;
    call signature.add(0, E^type);
    ARGSX^signature := signature;
end
}

-- Generation de code
#gen{
do
    ARGSX^code := E^code + ARGSX1^code;
end
}

ARGSX -> #up #gen ;

-- Remonte la signature
#up{
do
    ARGSX^signature := new Signature();
end
}

-- Generation de code
#gen{
do
    ARGSX^code := "";
end
}

end
