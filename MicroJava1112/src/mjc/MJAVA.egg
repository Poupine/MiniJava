-- PROJET3 STL 11-12 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

-- La table des declarations. Accessible par (presque) tout le monde...
-- Peut-on faire une variable globale au compilo ?
inh tdd : TDD for ENTITES, DEFCLASSE, DEFINTERFACE, SUPER, ETEND, IMPL, CORPS, DEFS, DEF, TYPE, 
            PARFS, PARF, PARFSX, MCORPS,  BLOC, INSTS, INST, E, AFFX, ER, ES, ERX, T, ESX, F, TX,
            ARGS, ARGSX, Q, SIX;

-- la classe courante
inh clazz : Clazz for SUPER, CORPS, ETEND, IMPL, DEFS, DEF, MCORPS, BLOC, INSTS, INST,
            E, AFFX, ER, ERX, ES, ESX, T, TX, F, ARGS, ARGSX, Q, SIX;

-- Le TYPAGE
syn type : DTYPE for TYPE, PARF, AFFX, E, ER, ERX, ES, ESX, T, TX, F, Q;
inh ltype : DTYPE for ERX, ESX, TX, Q;
inh lclazz : Clazz for Q;
inh lname : STRING for Q;

-- La signature des methodes
syn signature : Signature for PARFS, PARFSX, ARGS, ARGSX;

-- Le domaine des operateurs
syn domain : Domain for OPREL, OPADD, OPMUL, OPUN;

inh tds : TDS for PARFS, PARFSX, PARF, MCORPS, BLOC, INST, INSTS, SIX, E, AFFX, ER, ERX, ES, ESX, T, TX, F, Q, ARGS, ARGSX;
-- les terminaux 

space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar interface is  "interface";
sugar etend is  "extends";
sugar implemente is  "implements";
sugar retour is  "return";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
--The AXIOM
PROGRAMME -> #init ENTITES #gen;
global
   machine : AbstractMachine;
   t : TDD;
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   t := new TDD();
   ENTITES^tdd := t;
end
}

#gen {
local
do
    call machine.writeCode(PROGRAMME^source.getFileName(), "");
    write "table des classes " + t;
end
}

-- Entites : Declaration of classes and interfaces
ENTITES -> ;

ENTITES -> DEFCLASSE ENTITES  ;

ENTITES -> DEFINTERFACE ENTITES  ;

-- definition d'une classe
DEFCLASSE -> classe ident #down #tdd SUPER CORPS;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(ident^txt, false);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tdd {
do
    -- Vérifie que l'identifiant de la classe n'existe pas déjà.
    info := DEFCLASSE^tdd.containsKey(ident^txt);
    if info then
        error(err_class_exists, ident^txt);
    else
        -- Ajout à la table des déclarations.
        call DEFCLASSE^tdd.put(ident^txt, clazz);
    end
end
}

--DEFCLASSE -> classe ident etend ident CORPS ;
--DEFCLASSE -> classe ident implemente ident CORPS ;
--DEFCLASSE -> classe ident etend ident implemente ident CORPS ;
DEFINTERFACE -> interface ident #down #tdd SUPER CORPS;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(ident^txt, true);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tdd {
do
    -- Vérifie que l'identifiant de l'interface n'existe pas déjà.
    info := DEFINTERFACE^tdd.containsKey(ident^txt);
    if info then
        -- Ne fait rien puisque la declaration de la classe est invalide
    else
        -- Ajout à la table de déclarations.
        call DEFINTERFACE^tdd.put(ident^txt, clazz);
    end
end
}

--DEFINTERFACE -> interface ident etend ident CORPS;
-- 1 extends maximum suivi d'un implements maximum
SUPER -> ETEND IMPL #checkcompatible ;

-- Teste la compatibilite de ETEND et IMPL
#checkcompatible{
do
    if SUPER^clazz.testExtendImplementCompatible() then
        -- Le cas cool, rien a faire, pas de problemes
    else
        -- TODO Generer une erreur : incompatibilite de signatures entre l'extend et l'implement
    end
end
}

ETEND -> ;

ETEND -> etend ident #up ;

-- Verifie la validite de l'extend et l'enregistre dans la classe
#up{
local
    ext : Clazz;
do
    ext := ETEND^tdd.get(ident^txt);
    -- Vérifie qu'on peut hériter de l'identifiant spécifié.
    if (ext /= nil & ETEND^clazz.canExtend(ext)) then
        -- Vérifie qu'on n'hérite que d'une seule classe.
        if ETEND^clazz.getExtended() = nil then
            call ETEND^clazz.setExtended(ext);
        else
            error(err_max_ext_one, ETEND^clazz.getName());
        end
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if ETEND^clazz.isInterfaze() then
            error(err_interface_cannot_extend_class, ETEND^clazz.getName(), ident^txt);
        else
            if ext = nil then
                error(err_unknown_class, ident^txt);
            else
                error(err_class_cannot_extend_interface, ETEND^clazz, ident^txt);
            end
        end
    end
end
}

IMPL -> ;

IMPL -> implemente ident #up ;

-- Verifie la validite de l'implements et l'enregistre dans la classe
#up{
local
    impl : Clazz;
do
    impl := IMPL^tdd.get(ident^txt);
    -- Vérifie qu'on peut implémenter l'identifiant spécifié.
    if (impl /= nil & IMPL^clazz.canImplement(impl)) then
        call IMPL^clazz.setImplemented(impl);
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if IMPL^clazz.isInterfaze() then
            error(err_interface_cannot_implement_class, IMPL^clazz.getName(), ident^txt);
        else
            error(err_unknown_interface, ident^txt);
       end
    end
end
}

CORPS -> aco DEFS acf ;

-- les attributs
DEFS -> ;

DEFS -> DEF DEFS ;

-- attribut
DEF ->  TYPE ident pv #attr ;

-- Ajoute un attribut.
#attr {
do
    if DEF^clazz.hasAttribute(ident^txt) then
        error(err_attribute_already_named, ident^txt);
    else
        call DEF^clazz.addAttribute(ident^txt, TYPE^type);
    end
end
}

-- methode (fonction) 
DEF ->  TYPE ident #checkname paro #down PARFS parf #check #downbody MCORPS ;

global
    tds : TDS;
    
-- Verifie la bonne denomination de la methode
#checkname {
do
    if DEF^clazz.validMethodName(ident^txt) then
        if DEF^clazz.validMethodType(ident^txt, TYPE^type) then
            -- OK
        else
            -- ERROR
            -- TODO: Type de retour invalide
        end
    else
        -- ERROR
        error(err_meth_name, DEF^clazz.getName());
    end
end
}

-- Passe la tds a PARFS
#down{
do
    tds := new TDS();
    PARFS^tds := tds;
end
}

-- Verifie la validite de la signature
#check{
local
    
do
    if DEF^clazz.addMethod(ident^txt, TYPE^type, PARFS^signature) then
        -- OK
    else
        -- ERROR
        error(err_wrong_signature, PARFS^signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
end
}

-- methode (procedure)
DEF ->  void ident #checkname paro #down PARFS parf #check #downbody MCORPS ;

global
    tds : TDS;
    
-- Verifie la bonne denomination de la methode
#checkname {
do
    if DEF^clazz.validMethodName(ident^txt) then
        if DEF^clazz.validMethodType(ident^txt, new DTYPE("Null", 1)) then
            -- OK
        else
            -- ERROR
            -- TODO: Type de retour invalide
        end
    else
        -- ERROR
        error(err_meth_name, DEF^clazz.getName());
    end
end
}

-- Passe la tds a PARFS
#down{
do
    tds := new TDS();
    PARFS^tds := tds;
end
}

-- Verifie la validite de la signature
#check{
local
    
do
    if DEF^clazz.addMethod(ident^txt, new DTYPE("Null", 1), PARFS^signature) then
        -- OK
    else
        -- ERROR
        error(err_wrong_signature, PARFS^signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
end
}

-- dans classe ou dans interface
MCORPS -> pv #check ;

-- Verifie qu'on est dans une interface !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        -- Rien a faire
    else
        error(err_meth_not_specified, MCORPS^clazz.getName());
    end
end
}

MCORPS -> #check BLOC ;

-- Verifie qu'on est dans une classe concrete !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        error(err_meth_body_in_interface, MCORPS^clazz.getName());
    else
        -- Rien à faire
    end
end
}

-- constructeur
DEF -> ident #checkname paro #down PARFS #check parf #downbody BLOC ;

global
    tds : TDS;
    
-- Verifie la bonne denomination du constructeur
#checkname {
do
    if ident^txt.equals(DEF^clazz.getName()) then
        -- OK
    else
        -- ERROR
        error(err_meth_name, DEF^clazz.getName());
    end
end
}

-- Passe la tds a PARFS
#down{
do
    tds := new TDS();
    PARFS^tds := tds;
end
}

-- Verifie la validite de la signature
#check{
local
    
do
    if DEF^clazz.addConstructor(PARFS^signature) then
        -- OK
    else
        -- ERROR
        error(err_wrong_signature, PARFS^signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    BLOC^tds := tds;
end
}

-- les types
TYPE-> int #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Integer", 1);
end
}

TYPE-> bool #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Boolean", 1);
end
}

TYPE-> ident #type ;

-- Set le type de TYPE
#type{
local
    clazz : Clazz;
do
    clazz := TYPE^tdd.get(ident^txt);
    if clazz /= nil then
        TYPE^type := new Pointer(clazz);
    else
        error(err_unknown_class, ident^txt);
    end
end
}

-- parametres de methodes
PARFS -> #up ;

-- Remonte la signature
#up{
do
    PARFS^signature := new Signature();
end
}

PARFS ->  PARF PARFSX #up ;

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := PARFSX^signature;
    call signature.add(0, PARF^type);
    PARFS^signature := signature;
end
}

PARFSX -> #up ;

-- Remonte la signature
#up{
do
    PARFSX^signature := new Signature();
end
}

PARFSX -> virg  PARF  PARFSX #up ;

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := PARFSX1^signature;
    call signature.add(0, PARF^type);
    PARFSX^signature := signature;
end
}

PARF ->  TYPE ident #sign ;

-- Ajoute l'element dans la tds et remonte le type
#sign{
do
    -- TODO: Vérifier que l'argument n'existe pas déjà dans la tds.
    PARF^type := TYPE^type;
    call PARF^tds.inserer(ident^txt, new INFO(TYPE^type));
end
}

-- corps de methode et bloc d'instructions
BLOC ->  aco INSTS acf ;

-- instructions
INSTS -> ;

INSTS -> INST INSTS ;

-- declaration de variable locale avec ou sans init
INST-> TYPE ident #check AFFX pv #checktype ;

-- Teste l'absence de ident dans la tds
-- et dans la clazz.
-- TODO: Choisir si on accepte le hidding.
-- Manu: Etant donne qu'on a pas de mot clef this ou super, je pense qu'il vaut mieux le refuser
#check{
local
    info : INFO;
do
    info := INST^tds.chercherGlobalement(ident^txt);
    if info /= nil then
        -- TODO: genere le message d'erreur EXISTING
    else
        if INST^clazz.hasAttribute(ident^txt) then
            -- TODO: generer un message d'erreur HIDDING
        end
    end
end
}

-- Teste la compatibilite des types et affecte ident dans la tds.
#checktype{
do
    if AFFX^type.isType(TYPE^type) then
        call INST^tds.inserer(ident^txt, new INFO(TYPE^type));
    else
        -- TODO: genere un message d'erreur
    end
end
}

-- instruction expression
INST ->  E pv ;

-- bloc d'instructions
INST -> #tds BLOC ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(INST^tds);
end
}

-- conditionnelle
INST -> si paro #tds E parf  BLOC SIX ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(INST^tds);
end
}

SIX -> ;

SIX -> sinon #tds BLOC ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(SIX^tds);
end
}

-- return
INST ->  retour E pv ;

-- les expressions
E ->  ER AFFX #checktype #up ;

-- Teste la compatibilite des types
#checktype{
do
    if AFFX^type /= nil then
    if AFFX^type.isType(ER^type) then
        -- OK
    else
        -- TODO: genere un message d'erreur
    end
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    if AFFX^type = nil then
        E^type := ER^type;
    else
        E^type := AFFX^type;
    end
end
}

-- affectation
AFFX ->  affect ER #up ;

-- Remonte les attributs :
--  * type
#up{
do
    AFFX^type := ER^type;
end
}

AFFX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    AFFX^type := nil;
end
}

-- relation
ER -> ES #down ERX #up ;

-- Passe le type de gauche a ERX
#down{
do
    ERX^ltype := ES^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ER^type := ERX^type;
end
}

ES ->  T #down ESX #up ;

-- Passe le type de gauche a ESX
#down{
do
    ESX^ltype := T^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ES^type := ESX^type;
end
}

ERX ->  OPREL ES #checktype #up ;

-- Verifie la compatibilite de ltype et de ES^type avec OPREL^domain
#checktype{
do
    -- TODO
    if OPREL^domain.accepts(0, ERX^ltype) then
        call OPREL^domain.restrict(0,ERX^ltype);
        if OPREL^domain.accepts(1,ES^type) then
            call OPREL^domain.restrict(0,ES^type);
        else
            -- ERROR
            -- TODO erreur dans le type de ES
        end
    else
        -- ERROR
        -- TODO erreur dans le type de ERX
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ERX^type := OPREL^domain.getReturnType();
end
}

ERX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    ERX^type := ERX^ltype;
end
}

OPREL -> inf #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> infeg #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> sup #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> supeg #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> eg #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> neg #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- addition, ...
ESX -> OPADD T #checktype #down ESX #up ;

-- Verifie la compatibilite de ltype et de ES^type avec OPADD^domain
#checktype{
do
    -- TODO
    if OPADD^domain.accepts(0, ESX^ltype) then
        call OPADD^domain.restrict(0,ESX^ltype);
        if OPADD^domain.accepts(1,T^type) then
            call OPADD^domain.restrict(1,T^type);
        else
            -- ERROR
            -- TODO erreur dans le type de T
        end
    else
        -- ERROR
        -- TODO erreur dans le type de ESX
    end
end
}

-- Passe le type de gauche a ESX
#down{
do
    -- TODO
    ESX1^ltype := OPADD^domain.getReturnType();
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ESX^type := ESX1^type;
end
}

ESX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    ESX^type := ESX^ltype;
end
}

OPADD -> plus #up ;

-- Remonte le domaine
#up{
do
    OPADD^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPADD -> moins #up ;

-- Remonte le domaine
#up{
do
    OPADD^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPADD -> ou #up ;

-- Remonte le domaine
#up{
do
    OPADD^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Boolean",1), new DTYPE("Boolean",1));
end
}

T ->  F #down TX #up ;

-- Passe le type de gauche a ESX
#down{
do
    TX^ltype := F^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    T^type := TX^type;
end
}

-- multiplication, ...
TX -> OPMUL F #checktype #down TX #up ;

-- Verifie la compatibilite de ltype et de ES^type avec OPREL^domain
#checktype{
do
    -- TODO
    if OPMUL^domain.accepts(0, TX^ltype) then
        call OPMUL^domain.restrict(0,TX^ltype);
        if OPMUL^domain.accepts(1,F^type) then
            call OPMUL^domain.restrict(0,F^type);
        else
            -- ERROR
            -- TODO erreur dans le type de F
        end
    else
        -- ERROR
        -- TODO erreur dans le type de TX
    end
end
}

-- Passe le type de gauche a ESX
#down{
do
    -- TODO
    TX1^ltype := OPMUL^domain.getReturnType();
end
}

-- Remonte les attributs :
--  * type
#up{
do
    TX^type := TX1^type;
end
}

TX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    TX^type := TX^ltype;
end
}

OPMUL -> mult #up ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPMUL -> div #up ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPMUL -> mod #up ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPMUL -> et #up ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Boolean",1), new DTYPE("Boolean",1));
end
}

-- expressions de base
F -> entier #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Integer", 1);
end
}

F -> vrai #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Boolean", 1);
end
}

F -> faux #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Boolean", 1);
end
}

-- unaire
F ->  OPUN F #checktype #up ;

-- Verifie la compatibilite de ltype et de ES^type avec OPUN^domain
#checktype{
do
    -- TODO
    if OPUN^domain.accepts(0, F1^type) then
        call OPUN^domain.restrict(0,F1^type);
    else
        -- ERROR
        -- TODO erreur dans le type de F
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    -- TODO: Gerer la modification eventuelle par operation
    F^type := OPUN^domain.getReturnType();
end
}

OPUN -> plus #up ;

-- Remonte le domaine
#up{
do
    OPUN^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPUN -> moins #up ;

-- Remonte le domaine
#up{
do
    OPUN^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPUN -> non #up ;

-- Remonte le domaine
#up{
do
    OPUN^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Boolean",1));
end
}

-- null
F -> null #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Null", 1);
end
}

F ->  paro E parf #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := E^type;
end
}

-- new
F -> nouveau TYPE paro ARGS parf #checksignature #up ;

-- Teste l'existence du constructeur
#checksignature{
local
    clazz : Clazz;
    constructors : MethodList;
do
    match TYPE^type
        with Pointer then
            clazz := TYPE^type.getClazz();
            constructors := clazz.getConstructors();
            if constructors.doAccept(ARGS^signature) then
                -- OK
                    -- DISCUSS
                    -- On a un petit probleme en cas d'ambiguite. Je m'explique :
                    -- les constructeur Toto(A a) et Toto(B b) sont definis.
                    --   - Aucune relation entre A et B
                    --   - A est une classe concrete
                    --   - B est une interface
                    --
                    -- maintenant on construit une classe C extend A implements B...
                    -- Et quel constructeur on prend pour Toto(c) avec c de classe C ???
            else
                -- ERROR
                -- TODO erreur constructeur inconnu
            end
        else
            -- ERROR
            -- TODO On ne peut instancier un type primitif de cette maniere
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    F^type := TYPE^type;
end
}

F ->  ident #down Q #up ;

-- Passe le type de gauche a Q
#down{
local
    info : INFO;
do
   info := F^tds.chercherGlobalement(ident^txt);
    if info = nil then
        Q^ltype := F^clazz.getAttribute(ident^txt);
    else
        Q^ltype := info.getType();
    end
    Q^lclazz := F^clazz;
    Q^lname := ident^txt;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    F^type := Q^type;
end
}

-- Q = qualificateur de variable
Q -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    Q^type := Q^ltype;
end
}

-- acces attribut
Q ->  pt ident #down Q #up ;

-- Passe le type de gauche a Q
#down{
local
    type : DTYPE;
    clazz : Clazz;
do
    match Q^ltype
        with Pointer then
            clazz := Q^ltype.getClazz();
            Q1^lclazz := clazz;
            Q1^ltype := clazz.getAttribute(ident^txt);
            Q1^lname := ident^txt;
        else
            -- TODO: Genere un erreur
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
   Q^type := Q1^type;
end
}

-- arguments d'appel de methode
Q ->  paro ARGS parf #down Q #up ;

-- Passe le type de gauche a Q
#down{
local
    methodList : MethodList;
do
    if Q^lclazz = nil then
        -- ERROR
        -- TODO on ne peut pas avoir un appel de method sur un type !
    else
        methodList := Q^lclazz.getMethodList(Q^lname);
        if methodList.doAccept(ARGS^signature) then
            -- C'est ok
        -- DISCUSS
        -- On a un petit probleme en cas d'ambiguite. Je m'explique :
        -- les methodes Toto(A a) et Toto(B b) sont definies.
        --   - Aucune relation entre A et B
        --   - A est une classe concrete
        --   - B est une interface
        --
        -- maintenant on construit une classe C extend A implements B...
        -- Et quel methode on prend pour Toto(c) avec c de classe C ???
            Q1^ltype := methodList.getReturnType();
            Q1^lclazz := nil;
            Q1^lname := nil;
        else
            -- TODO: Generer une erreur: parametres d'appel incorrects
        end
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
   Q^type := Q1^type;
end
}

ARGS -> E ARGSX #up ;

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := ARGSX^signature;
    call signature.add(0, E^type);
    ARGS^signature := signature;
end
}

ARGS -> #up ;

-- Remonte la signature
#up{
do
    ARGS^signature := new Signature();
end
}

ARGSX -> virg E ARGSX #up ;

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := ARGSX1^signature;
    call signature.add(0, E^type);
    ARGSX^signature := signature;
end
}

ARGSX -> #up ;

-- Remonte la signature
#up{
do
    ARGSX^signature := new Signature();
end
}


end
