-- PROJET3 STL 11-12 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

-- La table des declarations. Accessible par (presque) tout le monde...
-- Peut-on faire une variable globale au compilo ?
inh tdd : TDD for ENTITES, DEFCLASSE, DEFINTERFACE, SUPER, ETEND, IMPL, CORPS, DEFS, DEF, TYPE, 
            PARFS, PARF, PARFSX, MCORPS,  BLOC, INSTS, INST, E, AFFX, ER, ES, ERX, T, ESX, F, TX,
            ARGS, ARGSX, Q, SIX;

-- la classe courante
inh clazz : Clazz for SUPER, CORPS, ETEND, IMPL, DEFS, DEF, MCORPS;

-- Le TYPAGE
syn type : DTYPE for TYPE;
-- La signature des methodes
inh signature : Method for PARFS;

inh tds : TDS for PARFS, MCORPS, BLOC, INST, INSTS;
-- les terminaux 

space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar interface is  "interface";
sugar etend is  "extends";
sugar implemente is  "implements";
sugar retour is  "return";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
--The AXIOM
PROGRAMME -> #init ENTITES #gen;
global
   machine : AbstractMachine;
   t : ClassTable;
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   t := new ClassTable();
   ENTITES^tdd := t;
end
}

#gen {
local
do
    call machine.writeCode(PROGRAMME^source.getFileName(), "");
    write "table des classes " + t;
end
}

-- Entites : Declaration of classes and interfaces
ENTITES -> ;

ENTITES -> DEFCLASSE ENTITES  ;

ENTITES -> DEFINTERFACE ENTITES  ;

-- definition d'une classe
DEFCLASSE -> classe ident #check #down SUPER CORPS #tds;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;

-- Verifie la validite de l'identifiant en tant que nom de classe
#check{
do
    info := DEFCLASSE^tdd.containsKey(ident^txt);
    if info then
        error(err_class_exists, ident^txt);
    else
        -- Rien a faire.
    end    
end
}

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(false);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tds {
do
    if info then
        error(err_class_exists, ident^txt);
    else
        call DEFCLASSE^tdd.put(ident^txt, clazz);
    end
end
}

--DEFCLASSE -> classe ident etend ident CORPS ;
--DEFCLASSE -> classe ident implemente ident CORPS ;
--DEFCLASSE -> classe ident etend ident implemente ident CORPS ;
DEFINTERFACE -> interface ident #check #down SUPER CORPS #tds;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;

-- Verifie la validite de l'identifiant en tant que nom de classe
#check{
do
    info := DEFINTERFACE^tdd.containsKey(ident^txt);
    if info then
        error(err_class_exists, ident^txt);
    else
        -- Rien a faire.
    end    
end
}

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(false);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tds {
do
    if info then
        -- Ne fait rien puisque la declaration de la classe est invalide
    else
        call DEFINTERFACE^tdd.put(ident^txt, clazz);
    end
end
}

--DEFINTERFACE -> interface ident etend ident CORPS;
-- 1 extends maximum suivi d'un implements maximum
SUPER -> ETEND IMPL ;

ETEND -> ;

ETEND -> etend ident #up ;

-- Verifie la validite de l'extend et l'enregistre dans la classe
#up{
local
    ext : Clazz;
do
    ext := ETEND^tdd.get(ident^txt);
    if ETEND^clazz.canExtend(ext) then
        call ETEND^clazz.setExtended(ext);
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if ETEND^clazz.isInterfaze() then
            error(err_interface_cannot_extend_class, ETEND^clazz.getName(), ext.getName());
        else
            error(err_class_cannot_extend_interface, ETEND^clazz.getName(), ext.getName());
        end
    end
end
}

IMPL -> ;

IMPL -> implemente ident #up ;

-- Verifie la validite de l'implements et l'enregistre dans la classe
#up{
local
    ext : Clazz;
do
    ext := IMPL^tdd.get(ident^txt);
    if IMPL^clazz.canImplement(ext) then
        call IMPL^clazz.setImplemented(ext);
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if IMPL^clazz.isInterfaze() then
            error(err_interface_cannot_implement_class, IMPL^clazz.getName(), ext.getName());
        else
            error(err_class_cannot_implement_interface, IMPL^clazz.getName(), ext.getName());
        end
    end
end
}

CORPS -> aco DEFS acf ;

-- les attributs
DEFS -> ;

DEFS -> DEF DEFS ;

-- attribut
DEF ->  TYPE ident pv #attr ;

-- Ajoute un attribut.
#attr {
do
    if DEF^clazz.hasAttribute(ident^txt) then
        error(err_attribute_already_named, ident^txt);
    else
        call DEF^clazz.addAttribute(ident^txt, TYPE^type);
    end
end
}

-- methode (fonction) 
DEF ->  TYPE ident paro #down PARFS parf #check #downbody MCORPS ;

global
    signature : Method;
    valid : BOOLEAN;
    tds : TDS;
    
-- Passe l'objet de signature a PARFS
#down{
do
    signature := new Method(ident^txt, TYPE^type);
    tds := new TDS();
    PARFS^tds := tds;
    PARFS^signature := signature;
end
}

-- Verifie la validite de la signature
#check{
do
    valid := DEF^clazz.addableMethod(signature);
    if valid then
        -- Rien a faire
    else
        -- Envoi d'un message d'erreur
        -- TODO: Specifier un peu l'erreur.
        -- #Maucais type de retour
        -- #Signature deja existante a l'identique
        error(err_wrong_signature, signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
end
}

-- methode (procedure)
DEF ->  void ident paro #down PARFS parf #check #downbody MCORPS ;

global
    signature : Method;
    valid : BOOLEAN;
    tds : TDS;
    
-- Passe l'objet de signature ainsi qu'une tds a PARFS
#down{
do
    signature := new Method(ident^txt, nil);
    tds := new TDS();
    PARFS^tds := tds;
    PARFS^signature := signature;
end
}

-- Verifie la validite de la signature
#check{
do
    valid := DEF^clazz.addableMethod(signature);
    if valid then
        -- Rien a faire
    else
        -- Envoi d'un message d'erreur
        -- TODO: Specifier un peu l'erreur.
        -- #Maucais type de retour
        -- #Signature deja existante a l'identique
        error(err_wrong_signature, signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
end
}

-- dans classe ou dans interface
MCORPS -> pv #check ;

-- Verifie qu'on est dans une interface !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        -- Rien a faire
    else
        -- TODO: Ecrire le message d'erreur
    end
end
}

MCORPS -> #check BLOC ;

-- Verifie qu'on est dans une classe concrete !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        -- TODO: Ecrire le message d'erreur
    else
        -- Rien a faire
    end
end
}

-- TODO: Under

-- constructeur
DEF -> ident paro #down PARFS #check parf #downbody BLOC ;

global
    signature : Method;
    valid : BOOLEAN;
    tds : TDS;
    
-- Passe l'objet de signature ainsi qu'une tds a PARFS
#down{
do
    signature := new Method(ident^txt, nil);
    tds := new TDS();
    PARFS^tds := tds;
    PARFS^signature := signature;
end
}

-- Verifie la validite de la signature
#check{
do
    valid := DEF^clazz.addableMethod(signature);
    if valid then
        -- Rien a faire
    else
        -- Envoi d'un message d'erreur
        -- TODO: Specifier un peu l'erreur.
        -- #Maucais type de retour
        -- #Signature deja existante a l'identique
        error(err_wrong_signature, signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    BLOC^tds := tds;
end
}

-- les types
TYPE-> int #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Integer", 1);
end
}

TYPE-> bool #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Boolean", 1);
end
}

TYPE-> ident #type ;

-- Set le type de TYPE
#type{
local
    clazz : DTYPE;
do
    clazz := TYPE^tdd.getClazz(ident^txt);
    -- TODO : Creer une class Pointer
    TYPE^type := new Pointer(clazz);
end
}

-- parametres de methodes
PARFS ->  ;
PARFS ->  PARF PARFSX ;
PARFSX ->  ;
PARFSX -> virg  PARF  PARFSX ;
PARF ->  TYPE ident  ;
-- corps de methode et bloc d'instructions
BLOC ->  aco INSTS acf  ;

-- instructions
INSTS ->   ;
INSTS ->  INST INSTS  ;
-- declaration de variable locale avec ou sans init
INST->  TYPE ident AFFX pv ;
-- instruction expression
INST ->  E pv ;
-- bloc d'instructions
INST ->  BLOC  ;
-- conditionnelle
INST ->  si paro E parf BLOC SIX ;

SIX ->;
-- return
INST ->  retour E pv ;
-- les expressions
E ->  ER AFFX ;
-- affectation
AFFX ->  affect ER  ;
AFFX -> ;
-- relation
ER ->   ES ERX ;
ES ->  T ESX ;
ERX ->  OPREL ES ;
ERX -> ;
OPREL -> inf ;
OPREL -> infeg ;
OPREL -> sup ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;
-- addition, ...
ESX ->   OPADD T ESX ;
ESX ->;
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;
T ->  F TX ;
-- multiplication, ...
TX ->   OPMUL F TX ;
TX -> ;
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;
-- expressions de base
F -> entier  ;
F -> vrai  ;
F -> faux  ;
-- unaire
F ->  OPUN F ;
OPUN -> plus;
OPUN -> moins;
OPUN -> non;
-- null
F -> null  ;
F ->  paro E parf ;
-- new
F -> nouveau  TYPE paro ARGS parf  ;
F ->  ident Q ;
-- Q = qualificateur de variable
Q ->  ;
-- acces attribut
Q ->  pt ident  Q ;
-- arguments d'appel de methode
Q ->  paro ARGS parf Q ;

-- Pourquoi est-ce en double ? Erreur de ma part ?
-- -- arguments d'appel de methode
-- Q ->  paro ARGS parf Q ;
ARGS ->  E ARGSX  ;
ARGS -> ;
ARGSX ->   virg E ARGSX  ;
ARGSX -> ;

end
