-- PROJET3 STL 11-12 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

-- La table des declarations. Accessible par (presque) tout le monde...
-- Peut-on faire une variable globale au compilo ?
inh tdd : TDD for ENTITES, DEFCLASSE, DEFINTERFACE, SUPER, ETEND, IMPL, CORPS, DEFS, DEF, TYPE, 
            PARFS, PARF, PARFSX, MCORPS,  BLOC, INSTS, INST, E, AFFX, ER, ES, ERX, T, ESX, F, TX,
            ARGS, ARGSX, Q, SIX;

-- la classe courante
inh clazz : Clazz for SUPER, CORPS, ETEND, IMPL, DEFS, DEF, PARFS, PARFSX, PARF, MCORPS, BLOC, INSTS, INST,
            E, AFFX, ER, ERX, ES, ESX, T, TX, F, ARGS, ARGSX, Q, SIX;

-- Le TYPAGE
syn type : DTYPE for TYPE, PARF, AFFX, E, ER, ERX, ES, ESX, T, TX, F, Q;
inh ltype : DTYPE for ERX, ESX, TX, Q;
inh lclazz : Clazz for Q;
inh lname : STRING for Q;

-- La signature des methodes
syn signature : Signature for PARFS, PARFSX, ARGS, ARGSX;

-- Le domaine des operateurs
syn domain : Domain for OPREL, OPADD, OPMUL, OPUN;

inh tds : TDS for PARFS, PARFSX, PARF, MCORPS, BLOC, INST, INSTS, SIX, E, AFFX, ER, ERX, ES, ESX, T, TX, F, Q, ARGS, ARGSX;

-- Le retour des methodes
inh returns : DTYPE for MCORPS, BLOC, INSTS, INST, SIX;
inh hreturned : BOOLEAN for BLOC, INSTS, INST, SIX;
syn sreturned : BOOLEAN for BLOC, INSTS, INST, SIX;

-- les terminaux 

space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar interface is  "interface";
sugar etend is  "extends";
sugar implemente is  "implements";
sugar retour is  "return";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
--The AXIOM
PROGRAMME -> #init ENTITES #gen;
global
   machine : AbstractMachine;
   t : TDD;
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   t := new TDD();
   ENTITES^tdd := t;
end
}

#gen {
local
do
    call machine.writeCode(PROGRAMME^source.getFileName(), "");
    write "table des classes \n" + t;
end
}

-- Entites : Declaration of classes and interfaces
ENTITES -> ;

ENTITES -> DEFCLASSE ENTITES  ;

ENTITES -> DEFINTERFACE ENTITES  ;

-- definition d'une classe
DEFCLASSE -> classe ident #down #tdd SUPER CORPS #check ;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(ident^txt, false);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tdd {
do
    -- Vérifie que l'identifiant de la classe n'existe pas déjà.
    info := DEFCLASSE^tdd.containsKey(ident^txt);
    if info then
        -- ERROR
        error(err_class_exists, ident^txt);
    else
        -- Ajout à la table des déclarations.
        call DEFCLASSE^tdd.put(ident^txt, clazz);
    end
end
}

-- Verifie qu'on implemente bien l'interface
-- Ajoute (si necessaire) le constructeur par defaut.
#check{
local
    impl : Clazz;
    method : MethodList;
    signature : Signature;
do
    if clazz.checkImplements() then
    else
        impl := clazz.getImplemented();
        error(err_implement, clazz.getName(), impl.getName());
    end
    method := clazz.getConstructors();
    signature := new Signature();
    if method.doAccept(signature) then
        -- Le constructeur par defaut a ete redefini
    else
        call clazz.addConstructor(signature);
    end
end
}

--DEFCLASSE -> classe ident etend ident CORPS ;
--DEFCLASSE -> classe ident implemente ident CORPS ;
--DEFCLASSE -> classe ident etend ident implemente ident CORPS ;
DEFINTERFACE -> interface ident #down #tdd SUPER CORPS;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(ident^txt, true);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tdd {
do
    -- Vérifie que l'identifiant de l'interface n'existe pas déjà.
    info := DEFINTERFACE^tdd.containsKey(ident^txt);
    if info then
        -- Ne fait rien puisque la declaration de la classe est invalide
        -- ERROR
        error(err_class_exists, ident^txt);
    else
        -- Ajout à la table de déclarations.
        call DEFINTERFACE^tdd.put(ident^txt, clazz);
    end
end
}

--DEFINTERFACE -> interface ident etend ident CORPS;
-- 1 extends maximum suivi d'un implements maximum
SUPER -> ETEND IMPL #checkcompatible ;

-- Teste la compatibilite de ETEND et IMPL
#checkcompatible{
local
    extend : Clazz;
    impl : Clazz;
do
    if SUPER^clazz.testExtendImplementCompatible() then
        -- Le cas cool, rien a faire, pas de problemes
    else
        -- ERROR
        extend := SUPER^clazz.getExtended();
        impl := SUPER^clazz.getImplemented();
        error(err_extend_and_implement_incompatible, extend.getName(), impl.getName());
    end
end
}

ETEND -> ;

ETEND -> etend ident #up ;

-- Verifie la validite de l'extend et l'enregistre dans la classe
#up{
local
    ext : Clazz;
do
    ext := ETEND^tdd.get(ident^txt);
    -- Vérifie qu'on peut hériter de l'identifiant spécifié.
    if (ext /= nil & ETEND^clazz.canExtend(ext)) then
        -- Vérifie qu'on n'hérite que d'une seule classe.
        if ETEND^clazz.getExtended() = nil then
            call ETEND^clazz.setExtended(ext);
        else
            -- ERROR
            error(err_max_ext_one, ETEND^clazz.getName());
        end
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if ETEND^clazz.isInterfaze() then
            -- ERROR
            error(err_interface_cannot_extend_class, ETEND^clazz.getName(), ident^txt);
        else
            if ext = nil then
                -- ERROR
                error(err_unknown_class, ident^txt);
            else
                -- ERROR
                error(err_class_cannot_extend_interface, ETEND^clazz, ident^txt);
            end
        end
    end
end
}

IMPL -> ;

IMPL -> implemente ident #up ;

-- Verifie la validite de l'implements et l'enregistre dans la classe
#up{
local
    impl : Clazz;
do
    impl := IMPL^tdd.get(ident^txt);
    -- Vérifie qu'on peut implémenter l'identifiant spécifié.
    if (impl /= nil & IMPL^clazz.canImplement(impl)) then
        if IMPL^clazz.getImplemented() = nil then
            call IMPL^clazz.setImplemented(impl);
        else
            -- ERROR
            error(err_max_impl_one, IMPL^clazz.getName());
        end
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if IMPL^clazz.isInterfaze() then
            -- ERROR
            error(err_interface_cannot_implement_class, IMPL^clazz.getName(), ident^txt);
        else
            -- ERROR
            error(err_unknown_interface, ident^txt);
       end
    end
end
}

CORPS -> aco DEFS acf ;

-- les attributs
DEFS -> ;

DEFS -> DEF DEFS ;

-- attribut
DEF ->  TYPE ident pv #attr ;

-- Ajoute un attribut.
#attr {
do
    if DEF^clazz.hasAttribute(ident^txt) then
        -- ERROR
        error(err_attribute_already_named, ident^txt);
    else
        call DEF^clazz.addAttribute(ident^txt, TYPE^type);
    end
end
}

-- methode (fonction) 
DEF ->  TYPE ident #checkname paro #down PARFS parf #check #downbody MCORPS ;

global
    tds : TDS;
    
-- Verifie la bonne denomination de la methode
#checkname {
do
    if DEF^clazz.validMethodName(ident^txt) then
        if DEF^clazz.validMethodType(ident^txt, TYPE^type) then
            -- OK
        else
            -- ERROR
            error(err_wrong_signature, ident^txt);
        end
    else
        -- ERROR
        error(err_meth_name, DEF^clazz.getName());
    end
end
}

-- Passe la tds a PARFS
#down{
do
    tds := new TDS();
    PARFS^tds := tds;
end
}

-- Verifie la validite de la signature
#check{
local
    
do
    if DEF^clazz.addMethod(ident^txt, TYPE^type, PARFS^signature) then
        -- OK
    else
        -- ERROR
        error(err_wrong_signature, PARFS^signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
    MCORPS^returns := TYPE^type;
end
}

-- methode (procedure)
DEF ->  void ident #checkname paro #down PARFS parf #check #downbody MCORPS ;

global
    tds : TDS;
    
-- Verifie la bonne denomination de la methode
#checkname {
do
    if DEF^clazz.validMethodName(ident^txt) then
        if DEF^clazz.validMethodType(ident^txt, new DTYPE("Null", 1)) then
            -- OK
        else
            -- ERROR
            error(err_wrong_signature, ident^txt);
        end
    else
        -- ERROR
        error(err_meth_name, DEF^clazz.getName());
    end
end
}

-- Passe la tds a PARFS
#down{
do
    tds := new TDS();
    PARFS^tds := tds;
end
}

-- Verifie la validite de la signature
#check{
local
    
do
    if DEF^clazz.addMethod(ident^txt, new DTYPE("Null", 1), PARFS^signature) then
        -- OK
    else
        -- ERROR
        error(err_wrong_signature, PARFS^signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
    MCORPS^returns := nil;
end
}

-- dans classe ou dans interface
MCORPS -> pv #check ;

-- Verifie qu'on est dans une interface !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        -- Rien a faire
    else
        -- ERROR
        error(err_meth_not_specified, MCORPS^clazz.getName());
    end
end
}

MCORPS -> #check #down BLOC ;

-- Verifie qu'on est dans une classe concrete !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        -- ERROR
        error(err_meth_body_in_interface, MCORPS^clazz.getName());
    else
        -- Rien à faire
    end
end
}

-- Initialise la variable returned
#down{
do
    BLOC^hreturned := false;
end
}

-- constructeur
DEF -> ident #checkname paro #down PARFS #check parf #downbody BLOC ;

global
    tds : TDS;
    
-- Verifie la bonne denomination du constructeur
#checkname {
do
    if DEF^clazz.isInterfaze() then
        error(err_interface_constructor, DEF^clazz.getName());
    else
        if ident^txt.equals(DEF^clazz.getName()) then
            -- OK
        else
            -- ERROR
            error(err_constructor_name, DEF^clazz.getName());
        end
    end
end
}

-- Passe la tds a PARFS
#down{
do
    tds := new TDS();
    PARFS^tds := tds;
end
}

-- Verifie la validite de la signature
#check{
local
    
do
    if DEF^clazz.addConstructor(PARFS^signature) then
        -- OK
    else
        -- ERROR
        error(err_constructor, ident^txt);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    BLOC^tds := tds;
    BLOC^hreturned := false;
    BLOC^returns := nil;
end
}

-- les types
TYPE-> int #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Integer", 1);
end
}

TYPE-> bool #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Boolean", 1);
end
}

TYPE-> ident #type ;

-- Set le type de TYPE
#type{
local
    clazz : Clazz;
do
    clazz := TYPE^tdd.get(ident^txt);
    if clazz /= nil then
        TYPE^type := new Pointer(clazz);
    else
        TYPE^type := nil;
        -- ERROR
        error(err_unknown_class, ident^txt);
    end
end
}

-- parametres de methodes
PARFS -> #up ;

-- Remonte la signature
#up{
do
    PARFS^signature := new Signature();
end
}

PARFS ->  PARF PARFSX #up ;

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := PARFSX^signature;
    call signature.add(0, PARF^type);
    PARFS^signature := signature;
end
}

PARFSX -> #up ;

-- Remonte la signature
#up{
do
    PARFSX^signature := new Signature();
end
}

PARFSX -> virg  PARF  PARFSX #up ;

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := PARFSX1^signature;
    call signature.add(0, PARF^type);
    PARFSX^signature := signature;
end
}

PARF ->  TYPE ident #sign ;

-- Ajoute l'element dans la tds et remonte le type
#sign{
do
    -- TODO: Vérifier que l'argument n'existe pas déjà dans la tds.
    PARF^type := TYPE^type;
    if PARF^tds.chercherGlobalement(ident^txt) /= nil then
        -- ERROR
        error(err_variable_already_defined, ident^txt);
    else
        if PARF^clazz.hasAttribute(ident^txt) then
            -- ERROR
            error(err_hidding, ident^txt);
        else
            call PARF^tds.inserer(ident^txt, new INFO(TYPE^type));
        end
    end
end
}

-- corps de methode et bloc d'instructions
BLOC -> aco INSTS acf #up ;

-- Remonte les attributs
--  * sreturned
#up{
do
    BLOC^sreturned := INSTS^sreturned;
end
}

-- instructions
INSTS -> #up ;

-- Remonte les attributs
--  * sreturned
#up{
do
    INSTS^sreturned := INSTS^hreturned;
end
}

INSTS -> #testReturn INST #transmit INSTS #up ;

-- Passe le statut de retour a INSTS
#testReturn{
do
    if INSTS^hreturned then
        error(err_unreachable_code);
    end
end
}

-- Remonte les attributs
--  * sreturned
#transmit{
do
    INSTS1^hreturned := INST^sreturned;
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    INSTS^sreturned := INSTS1^sreturned;
end
}

-- declaration de variable locale avec ou sans init
INST-> TYPE ident #check AFFX pv #checktype #up ;

-- Teste l'absence de ident dans la tds
-- et dans la clazz.
-- TODO: Choisir si on accepte le hidding.
-- Manu: Etant donne qu'on a pas de mot clef this ou super, je pense qu'il vaut mieux le refuser
#check{
local
    info : INFO;
do
    info := INST^tds.chercherGlobalement(ident^txt);
    if info /= nil then
        -- ERROR
        error(err_attribute_already_named, ident^txt);
    else
        if INST^clazz.hasAttribute(ident^txt) then
            -- ERROR
            error(err_hidding, ident^txt);
        end
    end
end
}

-- Teste la compatibilite des types et affecte ident dans la tds.
#checktype{
do
    if AFFX^type /= nil then
        if AFFX^type.isType(TYPE^type) then
            call INST^tds.inserer(ident^txt, new INFO(TYPE^type));
        else
            -- ERROR
            error(err_type, AFFX^type.getName(), TYPE^type.getName());
        end
    else
    end
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^sreturned := INST^hreturned;
end
}

-- instruction expression
INST ->  E pv #up ;

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^sreturned := INST^hreturned;
end
}

-- bloc d'instructions
INST -> #tds BLOC #up ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(INST^tds);
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^sreturned := BLOC^sreturned;
end
}

-- conditionnelle
INST -> si paro #tds E parf BLOC SIX #up ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(INST^tds);
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^sreturned := BLOC^sreturned & SIX^sreturned;
end
}

SIX -> #up ;

-- Remonte les attributs
--  * sreturned
#up{
do
    SIX^sreturned := false;
end
}

SIX -> sinon #tds BLOC #up ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(SIX^tds);
end
}

-- Remonte les attributs
--  * sreturned
#up{
do
    SIX^sreturned := BLOC^sreturned;
end
}

-- return
INST ->  retour E pv #up ;

-- Remonte les attributs
--  * sreturned
#up{
do
    INST^sreturned := true;
    if E^type.isType(INST^returns) then
    else
        error(err_return_type, E^type.getName(), INST^returns.getName());
    end
end
}

-- les expressions
E ->  ER AFFX #checktype #up ;

-- Teste la compatibilite des types
#checktype{
do
    if AFFX^type /= nil then
    if AFFX^type.isType(ER^type) then
        -- OK
    else
        -- ERROR
        error(err_type, AFFX^type.getName(), ER^type.getName());
    end
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    if AFFX^type = nil then
        E^type := ER^type;
    else
        E^type := AFFX^type;
    end
end
}

-- affectation
AFFX ->  affect ER #up ;

-- Remonte les attributs :
--  * type
#up{
do
    AFFX^type := ER^type;
end
}

AFFX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    AFFX^type := nil;
end
}

-- relation
ER -> ES #down ERX #up ;

-- Passe le type de gauche a ERX
#down{
do
    ERX^ltype := ES^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ER^type := ERX^type;
end
}

ES ->  T #down ESX #up ;

-- Passe le type de gauche a ESX
#down{
do
    ESX^ltype := T^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ES^type := ESX^type;
end
}

ERX ->  OPREL ES #checktype #up ;

-- Verifie la compatibilite de ltype et de ES^type avec OPREL^domain
#checktype{
do
    -- TODO
    if OPREL^domain.accepts(0, ERX^ltype) then
        call OPREL^domain.restrict(0,ERX^ltype);
        if OPREL^domain.accepts(1,ES^type) then
            call OPREL^domain.restrict(0,ES^type);
        else
            -- ERROR
            error(err_type, ES^type.getName(), OPREL^domain.getType(1));
        end
    else
        -- ERROR
        error(err_type, ERX^ltype.getName(), OPREL^domain.getType(0));
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ERX^type := OPREL^domain.getReturnType();
end
}

ERX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    ERX^type := ERX^ltype;
end
}

OPREL -> inf #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> infeg #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> sup #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> supeg #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> eg #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPREL -> neg #up ;

-- Remonte le domaine
#up{
do
    OPREL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

-- addition, ...
ESX -> OPADD T #checktype #down ESX #up ;

-- Verifie la compatibilite de ltype et de ES^type avec OPADD^domain
#checktype{
do
    -- TODO
    if OPADD^domain.accepts(0, ESX^ltype) then
        call OPADD^domain.restrict(0,ESX^ltype);
        if OPADD^domain.accepts(1,T^type) then
            call OPADD^domain.restrict(1,T^type);
        else
            -- ERROR
            error(err_type, T^type.getName(), OPADD^domain.getType(1));
        end
    else
        -- ERROR
        error(err_type, ESX^ltype.getName(), OPADD^domain.getType(1));
    end
end
}

-- Passe le type de gauche a ESX
#down{
do
    ESX1^ltype := OPADD^domain.getReturnType();
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ESX^type := ESX1^type;
end
}

ESX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    ESX^type := ESX^ltype;
end
}

OPADD -> plus #up ;

-- Remonte le domaine
#up{
do
    OPADD^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPADD -> moins #up ;

-- Remonte le domaine
#up{
do
    OPADD^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPADD -> ou #up ;

-- Remonte le domaine
#up{
do
    OPADD^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Boolean",1), new DTYPE("Boolean",1));
end
}

T ->  F #down TX #up ;

-- Passe le type de gauche a ESX
#down{
do
    TX^ltype := F^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    T^type := TX^type;
end
}

-- multiplication, ...
TX -> OPMUL F #checktype #down TX #up ;

-- Verifie la compatibilite de ltype et de ES^type avec OPREL^domain
#checktype{
do
    if OPMUL^domain.accepts(0, TX^ltype) then
        call OPMUL^domain.restrict(0,TX^ltype);
        if OPMUL^domain.accepts(1,F^type) then
            call OPMUL^domain.restrict(0,F^type);
        else
            -- ERROR
            error(err_type, F^type.getName(), OPMUL^domain.getType(1));
        end
    else
        -- ERROR
            error(err_type, TX^ltype.getName(), OPMUL^domain.getType(1));
    end
end
}

-- Passe le type de gauche a ESX
#down{
do
    TX1^ltype := OPMUL^domain.getReturnType();
end
}

-- Remonte les attributs :
--  * type
#up{
do
    TX^type := TX1^type;
end
}

TX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    TX^type := TX^ltype;
end
}

OPMUL -> mult #up ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPMUL -> div #up ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPMUL -> mod #up ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPMUL -> et #up ;

-- Remonte le domaine
#up{
do
    OPMUL^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Boolean",1), new DTYPE("Boolean",1));
end
}

-- expressions de base
F -> entier #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Integer", 1);
end
}

F -> vrai #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Boolean", 1);
end
}

F -> faux #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Boolean", 1);
end
}

-- unaire
F ->  OPUN F #checktype #up ;

-- Verifie la compatibilite de ltype et de ES^type avec OPUN^domain
#checktype{
do
    if OPUN^domain.accepts(0, F1^type) then
        call OPUN^domain.restrict(0,F1^type);
    else
        -- ERROR
        error(err_type, F1^type.getName(), OPUN^domain.getType(0));
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    F^type := OPUN^domain.getReturnType();
end
}

OPUN -> plus #up ;

-- Remonte le domaine
#up{
do
    OPUN^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPUN -> moins #up ;

-- Remonte le domaine
#up{
do
    OPUN^domain := new Domain(new DTYPE("Integer",1), new DTYPE("Integer",1));
end
}

OPUN -> non #up ;

-- Remonte le domaine
#up{
do
    OPUN^domain := new Domain(new DTYPE("Boolean",1), new DTYPE("Boolean",1));
end
}

-- null
F -> null #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Null", 1);
end
}

F ->  paro E parf #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := E^type;
end
}

-- new
F -> nouveau TYPE paro ARGS parf #checksignature #up ;

-- Teste l'existence du constructeur
#checksignature{
local
    clazz : Clazz;
    constructors : MethodList;
do
    match TYPE^type
        with Pointer then
            clazz := TYPE^type.getClazz();
            constructors := clazz.getConstructors();
            if constructors.doAccept(ARGS^signature) then
                -- OK
                    -- DISCUSS
                    -- On a un petit probleme en cas d'ambiguite. Je m'explique :
                    -- les constructeur Toto(A a) et Toto(B b) sont definis.
                    --   - Aucune relation entre A et B
                    --   - A est une classe concrete
                    --   - B est une interface
                    --
                    -- maintenant on construit une classe C extend A implements B...
                    -- Et quel constructeur on prend pour Toto(c) avec c de classe C ???
            else
                -- ERROR
                error(err_unknown_constructor, ARGS^signature.toString());
            end
        else
            -- ERROR
            error(err_primitive_type);
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
    F^type := TYPE^type;
end
}

F ->  ident #down Q #up ;

-- Passe le type de gauche a Q
#down{
local
    info : INFO;
    attribut :DTYPE;
do
   info := F^tds.chercherGlobalement(ident^txt);
    if info = nil then
         attribut := F^clazz.getAttribute(ident^txt);
         if attribut = nil then
         --Error
            error(err_no_attribut, ident^txt);
         else 
            Q^ltype := attribut;
         end
    else
        Q^ltype := info.getType();
    end
    Q^lclazz := F^clazz;
    Q^lname := ident^txt;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    F^type := Q^type;
end
}

-- Q = qualificateur de variable
Q -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    Q^type := Q^ltype;
end
}

-- acces attribut
Q ->  pt ident #down Q #up ;

-- Passe le type de gauche a Q
#down{
local
    type : DTYPE;
    clazz : Clazz;
do
    match Q^ltype
        with Pointer then
            clazz := Q^ltype.getClazz();
            Q1^lclazz := clazz;
            Q1^ltype := clazz.getAttribute(ident^txt);
            Q1^lname := ident^txt;
        else
            -- ERROR
            error(err_primitive_types_have_no_fields);
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
   Q^type := Q1^type;
end
}

-- arguments d'appel de methode
Q ->  paro ARGS parf #down Q #up ;

-- Passe le type de gauche a Q
#down{
local
    methodList : MethodList;
do
    if Q^lclazz = nil then
        -- ERROR
        error(err_primitive_types_have_no_method);
    else
        methodList := Q^lclazz.getMethodList(Q^lname);
        if methodList = nil then
            -- ERROR
            error(err_no_such_method, Q^lname, Q^lclazz.getName());
        else
            if methodList.doAccept(ARGS^signature) then
                -- C'est ok
            -- DISCUSS
            -- On a un petit probleme en cas d'ambiguite. Je m'explique :
            -- les methodes Toto(A a) et Toto(B b) sont definies.
            --   - Aucune relation entre A et B
            --   - A est une classe concrete
            --   - B est une interface
            --
            -- maintenant on construit une classe C extend A implements B...
            -- Et quel methode on prend pour Toto(c) avec c de classe C ???
                Q1^ltype := methodList.getReturnType();
                Q1^lclazz := nil;
                Q1^lname := nil;
            else
                error(err_wrong_signature_call, Q^lname, ARGS^signature);
            end
        end
    end
end
}

-- Remonte les attributs :
--  * type
#up{
do
   Q^type := Q1^type;
end
}

ARGS -> E ARGSX #up ;

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := ARGSX^signature;
    call signature.add(0, E^type);
    ARGS^signature := signature;
end
}

ARGS -> #up ;

-- Remonte la signature
#up{
do
    ARGS^signature := new Signature();
end
}

ARGSX -> virg E ARGSX #up ;

-- Remonte la signature
#up{
local
    signature : Signature;
do
    signature := ARGSX1^signature;
    call signature.add(0, E^type);
    ARGSX^signature := signature;
end
}

ARGSX -> #up ;

-- Remonte la signature
#up{
do
    ARGSX^signature := new Signature();
end
}


end
