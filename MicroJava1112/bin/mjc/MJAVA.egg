-- PROJET3 STL 11-12 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

-- La table des declarations. Accessible par (presque) tout le monde...
-- Peut-on faire une variable globale au compilo ?
inh tdd : TDD for ENTITES, DEFCLASSE, DEFINTERFACE, SUPER, ETEND, IMPL, CORPS, DEFS, DEF, TYPE, 
            PARFS, PARF, PARFSX, MCORPS,  BLOC, INSTS, INST, E, AFFX, ER, ES, ERX, T, ESX, F, TX,
            ARGS, ARGSX, Q, SIX;

-- la classe courante
inh clazz : Clazz for SUPER, CORPS, ETEND, IMPL, DEFS, DEF, MCORPS;

-- Le TYPAGE
syn type : DTYPE for TYPE, AFFX, E, ER, ERX, ES, ESX, T, TX, F; --, Q;
inh ltype : DTYPE for ERX, ESX, TX; --, Q;

-- La signature des methodes
inh signature : Method for PARFS, PARFSX, PARF;

inh tds : TDS for PARFS, PARFSX, PARF, MCORPS, BLOC, INST, INSTS, SIX;
-- les terminaux 

space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar interface is  "interface";
sugar etend is  "extends";
sugar implemente is  "implements";
sugar retour is  "return";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
--The AXIOM
PROGRAMME -> #init ENTITES #gen;
global
   machine : AbstractMachine;
   t : TDD;
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   t := new TDD();
   ENTITES^tdd := t;
end
}

#gen {
local
do
    call machine.writeCode(PROGRAMME^source.getFileName(), "");
    write "table des classes " + t;
end
}

-- Entites : Declaration of classes and interfaces
ENTITES -> ;

ENTITES -> DEFCLASSE ENTITES  ;

ENTITES -> DEFINTERFACE ENTITES  ;

-- definition d'une classe
DEFCLASSE -> classe ident #down SUPER CORPS #tds;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(ident^txt, false);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tds {
do
    -- Vérifie que l'identifiant de la classe n'existe pas déjà.
    info := DEFCLASSE^tdd.containsKey(ident^txt);
    if info then
        error(err_class_exists, ident^txt);
    else
        -- Ajout à la table des déclarations.
        call DEFCLASSE^tdd.put(ident^txt, clazz);
    end
end
}

--DEFCLASSE -> classe ident etend ident CORPS ;
--DEFCLASSE -> classe ident implemente ident CORPS ;
--DEFCLASSE -> classe ident etend ident implemente ident CORPS ;
DEFINTERFACE -> interface ident #down SUPER CORPS #tds;

-- La classe.
global
    clazz : Clazz;
    info : BOOLEAN;

-- Cree l'objet classe et le passe en attribut a SUPER et CORPS
#down {
do
    clazz := new Clazz(ident^txt, false);
    SUPER^clazz := clazz;
    CORPS^clazz := clazz;
end
}

-- Ajoute la classe dans la table des classes. Verifie au passage qu'elle n'existe pas encore.
#tds {
do
    -- Vérifie que l'identifiant de l'interface n'existe pas déjà.
    info := DEFINTERFACE^tdd.containsKey(ident^txt);
    if info then
        -- Ne fait rien puisque la declaration de la classe est invalide
    else
        -- Ajout à la table de déclarations.
        call DEFINTERFACE^tdd.put(ident^txt, clazz);
    end
end
}

--DEFINTERFACE -> interface ident etend ident CORPS;
-- 1 extends maximum suivi d'un implements maximum
SUPER -> ETEND IMPL ;

ETEND -> ;

ETEND -> etend ident #up ;

-- Verifie la validite de l'extend et l'enregistre dans la classe
#up{
local
    ext : Clazz;
do
    ext := ETEND^tdd.get(ident^txt);
    -- Vérifie qu'on peut hériter de l'identifiant spécifié.
    if ETEND^clazz.canExtend(ext) then
        -- Vérifie qu'on n'hérite que d'une seule classe.
        if ETEND^clazz.getExtended() = nil then
            call ETEND^clazz.setExtended(ext);
        else
            error(err_max_ext_one, ETEND^clazz.getName());
        end
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if ETEND^clazz.isInterfaze() then
            error(err_interface_cannot_extend_class, ETEND^clazz.getName(), ext.getName());
        else
            error(err_class_cannot_extend_interface, ETEND^clazz.getName(), ext.getName());
        end
    end
end
}

IMPL -> ;

IMPL -> implemente ident #up ;

-- Verifie la validite de l'implements et l'enregistre dans la classe
#up{
local
    impl : Clazz;
do
    impl := IMPL^tdd.get(ident^txt);
    -- Vérifie qu'on peut implémenter l'identifiant spécifié.
    if IMPL^clazz.canImplement(impl) then
        -- Vérifie qu'on n'implémente qu'une seule interface.
        if IMPL^clazz.getImplemented() = nil then
            call IMPL^clazz.setImplemented(impl);
        else
            error(err_max_impl_one, IMPL^clazz.getName());
        end
    else
        -- Une specification du message d'erreur en fonction du type de class (interface
        -- ou classe concrete)
        if IMPL^clazz.isInterfaze() then
            error(err_interface_cannot_implement_class, IMPL^clazz.getName(), impl.getName());
        end
    end
end
}

CORPS -> aco DEFS acf ;

-- les attributs
DEFS -> ;

DEFS -> DEF DEFS ;

-- attribut
DEF ->  TYPE ident pv #attr ;

-- Ajoute un attribut.
#attr {
do
    if DEF^clazz.hasAttribute(ident^txt) then
        error(err_attribute_already_named, ident^txt);
    else
        call DEF^clazz.addAttribute(ident^txt, TYPE^type);
    end
end
}

-- methode (fonction) 
DEF ->  TYPE ident #checkname paro #down PARFS parf #check #downbody MCORPS ;

global
    signature : Method;
    valid : BOOLEAN;
    tds : TDS;
    
-- Verifie la bonne denomination de la methode
#checkname{
do
    if DEF^clazz.getName() = ident^txt then
        error(err_meth_name, DEF^clazz.getName());
    end
end
}

-- Passe l'objet de signature a PARFS
#down{
do
    signature := new Method(ident^txt, TYPE^type);
    tds := new TDS();
    PARFS^tds := tds;
    PARFS^signature := signature;
end
}

-- Verifie la validite de la signature
#check{
do
    valid := DEF^clazz.addableMethod(signature);
    if valid then
        call DEF^clazz.addMethod(signature);
    else
        -- Envoi d'un message d'erreur
        -- TODO: Specifier un peu l'erreur.
        -- #Mauvais type de retour
        -- #Signature deja existante a l'identique
        error(err_wrong_signature, signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
end
}

-- methode (procedure)
DEF ->  void ident #checkname paro #down PARFS parf #check #downbody MCORPS ;

global
    signature : Method;
    valid : BOOLEAN;
    tds : TDS;
    
-- Verifie la bonne denomination de la methode
#checkname{
do
    if DEF^clazz.getName() = ident^txt then
        error(err_meth_name, DEF^clazz.getName());
    end
end
}

-- Passe l'objet de signature ainsi qu'une tds a PARFS
#down{
do
    signature := new Method(ident^txt, nil);
    tds := new TDS();
    PARFS^tds := tds;
    PARFS^signature := signature;
end
}

-- Verifie la validite de la signature
#check{
do
    valid := DEF^clazz.addableMethod(signature);
    if valid then
        call DEF^clazz.addMethod(signature);
    else
        -- Envoi d'un message d'erreur
        -- TODO: Specifier un peu l'erreur.
        -- #Mauvais type de retour
        -- #Signature deja existante a l'identique
        error(err_wrong_signature, signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    MCORPS^tds := tds;
end
}

-- dans classe ou dans interface
MCORPS -> pv #check ;

-- Verifie qu'on est dans une interface !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        -- Rien a faire
    else
        error(err_meth_not_specified, MCORPS^clazz.getName());
    end
end
}

MCORPS -> #check BLOC ;

-- Verifie qu'on est dans une classe concrete !
#check{
do
    if MCORPS^clazz.isInterfaze() then
        error(err_meth_body_in_interface, MCORPS^clazz.getName());
    else
        -- Rien à faire
    end
end
}

-- constructeur
DEF -> ident #checkname paro #down PARFS #check parf #downbody BLOC ;

global
    signature : Method;
    valid : BOOLEAN;
    tds : TDS;

-- Verifie qu'on est dans une classe concrete ainsi que la bonne denomination du constructeur.
#checkname{
do
    if DEF^clazz.isInterfaze() then
        error(err_interface_constructor, DEF^clazz.getName());
    end
    if DEF^clazz.getName() /= ident^txt then
        error(err_constructor_name, DEF^clazz.getName());
    end
end
}
    
-- Passe l'objet de signature ainsi qu'une tds a PARFS
#down{
do
    signature := new Method(ident^txt, DEF^clazz);
    tds := new TDS();
    PARFS^tds := tds;
    PARFS^signature := signature;
end
}

-- Verifie la validite de la signature
#check{
do
    valid := DEF^clazz.addableConstructor(signature);
    if valid then
        -- Rien a faire
    else
        -- Envoi d'un message d'erreur
        -- TODO: Specifier un peu l'erreur.
        -- #Signature deja existante a l'identique
        error(err_wrong_signature, signature);
    end
end
}

-- Passe la tds au corps
#downbody{
do
    BLOC^tds := tds;
end
}

-- les types
TYPE-> int #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Integer", 1);
end
}

TYPE-> bool #type ;

-- Set le type de TYPE
#type{
do
    TYPE^type := new DTYPE("Boolean", 1);
end
}

TYPE-> ident #type ;

-- Set le type de TYPE
#type{
local
    clazz : DTYPE;
do
    clazz := TYPE^tdd.get(ident^txt);
    if clazz /= nil then
        -- TODO : Creer une class Pointer
        TYPE^type := clazz;
    else
        -- TODO: generer une erreur
    end
end
}

-- parametres de methodes
PARFS ->  ;
PARFS ->  PARF PARFSX ;
PARFSX ->  ;
PARFSX -> virg  PARF  PARFSX ;
PARF ->  TYPE ident #sign ;

-- Ajoute l'element dans la tds et dans la signature
#sign{
do
    call PARF^signature.addArgument(TYPE^type);
    call PARF^tds.inserer(ident^txt, new INFO(TYPE^type));
end
}

-- corps de methode et bloc d'instructions
BLOC ->  aco INSTS acf ;

-- instructions
INSTS -> ;

INSTS -> INST INSTS ;

-- declaration de variable locale avec ou sans init
INST-> TYPE ident #check AFFX pv #checktype ;

-- Teste l'absence de ident dans la tds
-- et dans la tdd.
-- TODO: Choisir si on accepte le hidding.
-- Manu: Etant donne qu'on a pas de mot clef this ou super, je pense qu'il vaut mieux le refuser
#check{
local
    info : INFO;
do
    info := INST^tds.chercherGlobalement(ident^txt);
    if info /= nil then
        -- TODO: genere le message d'erreur EXISTING
    else
        if INST^tdd.containsKey(ident^txt) then
            -- TODO: generer un message d'erreur HIDDING
        end
    end
end
}

-- Teste la compatibilite des types et affecte ident dans la tds.
#checktype{
do
    if AFFX^type.compareTo(TYPE^type) then
        call INST^tds.inserer(ident^txt, new INFO(TYPE^type));
    else
        -- TODO: genere un message d'erreur
    end
end
}

-- instruction expression
INST ->  E pv ;

-- bloc d'instructions
INST -> #tds BLOC ;

-- Genere une sous tds pour le bloc
#tds{
do
    BLOC^tds := new TDS(INST^tds);
end
}

-- conditionnelle
INST -> si paro E parf BLOC SIX ;

SIX -> ;
SIX -> sinon BLOC ;
-- return
INST ->  retour E pv ;

-- les expressions
E ->  ER AFFX #up ;

-- Remonte les attributs :
--  * type
#up{
do
    E^type := AFFX^type;
end
}

-- affectation
AFFX ->  affect ER #up ;

-- Remonte les attributs :
--  * type
#up{
do
    AFFX^type := ER^type;
end
}

AFFX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    AFFX^type := nil;
end
}

-- relation
ER -> ES #down ERX #up ;

-- Passe le type de gauche a ERX
#down{
do
    ERX^ltype := ES^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ER^type := ERX^type;
end
}

ES ->  T #down ESX #up ;

-- Passe le type de gauche a ESX
#down{
do
    ESX^ltype := T^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    ES^type := ESX^type;
end
}

ERX ->  OPREL ES #up ;

-- Remonte les attributs :
--  * type
#up{
do
    ERX^type := new DTYPE("Boolean", 1);
end
}

ERX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    ERX^type := ERX^ltype;
end
}

OPREL -> inf ;
OPREL -> infeg ;
OPREL -> sup ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;
-- addition, ...
ESX ->   OPADD T ESX #up ;

-- Remonte les attributs :
--  * type
#up{
do
    ESX^type := ESX1^type;
end
}

ESX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    ESX^type := ESX^ltype;
end
}

OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;
T ->  F #down TX #up ;

-- Passe le type de gauche a ESX
#down{
do
    TX^ltype := F^type;
end
}

-- Remonte les attributs :
--  * type
#up{
do
    T^type := TX^type;
end
}

-- multiplication, ...
TX -> OPMUL F TX #up ;

-- Remonte les attributs :
--  * type
#up{
do
    TX^type := TX1^type;
end
}

TX -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
    TX^type := TX^ltype;
end
}

OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;
-- expressions de base
F -> entier #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Integer", 1);
end
}

F -> vrai #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Boolean", 1);
end
}

F -> faux #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("Boolean", 1);
end
}

-- unaire
F ->  OPUN F #up ;

-- Remonte les attributs :
--  * type
#up{
do
    -- TODO: Gerer la modification eventuelle par operation
    F^type := F1^type;
end
}

OPUN -> plus;
OPUN -> moins;
OPUN -> non;
-- null
F -> null #up ;

-- Remonte les attributs :
--  * type
#up{
do
    -- TODO: Gerer la modification eventuelle par operation
    F^type := nil;
end
}

F ->  paro E parf #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := E^type;
end
}

-- new
F -> nouveau TYPE paro ARGS parf #up ;

-- Remonte les attributs :
--  * type
#up{
do
    F^type := TYPE^type;
end
}

F ->  ident #down Q #up ;

-- Passe le type de gauche a Q
#down{
local
    info : INFO;
do
   -- info := Q^tds.chercherGlobalement(ident^txt);
   -- Q^ltype := info.getType();
end
}

-- Remonte les attributs :
--  * type
#up{
do
    F^type := new DTYPE("test", 1); --Q^type;
end
}

-- Q = qualificateur de variable
Q -> #up ;

-- Remonte les attributs :
--  * type
#up{
do
   -- Q^type := Q^ltype;
end
}

-- acces attribut
Q ->  pt ident  Q ;

-- arguments d'appel de methode
Q ->  paro ARGS parf Q ;

-- Pourquoi est-ce en double ? Erreur de ma part ?
-- -- arguments d'appel de methode
-- Q ->  paro ARGS parf Q ;
ARGS ->  E ARGSX  ;
ARGS -> ;
ARGSX ->   virg E ARGSX  ;
ARGSX -> ;

end
